import 'dart:convert';

import 'package:dart_lnurl/dart_lnurl.dart';
import 'package:http/http.dart' as http;

class LNURLService {
  Future<LNURLPayResult> getPaymentResult(
      LNURLPayParams payParams, Map<String, String> qParams) async {
    /*
     5. LN WALLET makes a GET request using
        <callback><?|&>amount=<milliSatoshi>
        amount being the amount specified by the user in millisatoshis.
   */
    Uri uri = Uri.parse(payParams.callback).replace(queryParameters: qParams);
    var response = await http.get(uri).timeout(const Duration(seconds: 60));
    if (response.statusCode != 200 && response.statusCode != 201) {
      throw Exception('Failed to call ${payParams.domain} API');
    }
    /*
   6. LN Service takes the GET request and returns JSON response of form:
      {
        pr: string, // bech32-serialized lightning invoice
        routes: [] // an empty array
        "successAction": Object (optional)
      }
      or
      {"status":"ERROR", "reason":"error details..."}
  */
    Map<String, dynamic> parsedJson = json.decode(response.body);
    if (parsedJson['status'] == 'ERROR') {
      throw Exception(parsedJson['reason']);
    }
    return LNURLPayResult.fromJson(parsedJson);
  }

  Future<bool> processWithdrawRequest(
      LNURLWithdrawParams withdrawParams, Map<String, String> qParams) async {
    /*
     5. LN WALLET sends a GET to LN SERVICE in the form of
        <callback>
        <?|&> // either '?' or '&' depending on whether there is a query string already in the callback
        k1=<k1> // the k1 specified in the response above
        &pr=<lightning invoice> // the payment request generated by the wallet
   */
    Uri uri =
        Uri.parse(withdrawParams.callback).replace(queryParameters: qParams);
    var response = await http.get(uri).timeout(const Duration(seconds: 60));
    if (response.statusCode != 200 && response.statusCode != 201) {
      throw Exception('Failed to call ${withdrawParams.domain} API');
    }
    /*
   6. LN SERVICE sends a
      {"status": "OK"} or {"status": "ERROR", "reason": "error details..."}
      JSON response and then attempts to pay the invoices asynchronously.
  */
    Map<String, dynamic> parsedJson = json.decode(response.body);
    return parsedJson['status'] == 'OK';
  }
}
