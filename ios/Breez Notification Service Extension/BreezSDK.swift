// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(breez_sdkFFI)
import breez_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_breez_sdk_76fc_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_breez_sdk_76fc_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol BlockingBreezServicesProtocol {
    func `disconnect`() throws
    func `sendPayment`(`req`: SendPaymentRequest) throws -> SendPaymentResponse
    func `sendSpontaneousPayment`(`req`: SendSpontaneousPaymentRequest) throws -> SendPaymentResponse
    func `receivePayment`(`req`: ReceivePaymentRequest) throws -> ReceivePaymentResponse
    func `payLnurl`(`req`: LnUrlPayRequest) throws -> LnUrlPayResult
    func `withdrawLnurl`(`request`: LnUrlWithdrawRequest) throws -> LnUrlWithdrawResult
    func `lnurlAuth`(`reqData`: LnUrlAuthRequestData) throws -> LnUrlCallbackStatus
    func `reportIssue`(`req`: ReportIssueRequest) throws
    func `nodeCredentials`() throws -> NodeCredentials?
    func `nodeInfo`() throws -> NodeState
    func `signMessage`(`req`: SignMessageRequest) throws -> SignMessageResponse
    func `checkMessage`(`req`: CheckMessageRequest) throws -> CheckMessageResponse
    func `backupStatus`() throws -> BackupStatus
    func `backup`() throws
    func `paymentByHash`(`hash`: String) throws -> Payment?
    func `listPayments`(`req`: ListPaymentsRequest) throws -> [Payment]
    func `sweep`(`req`: SweepRequest) throws -> SweepResponse
    func `fetchFiatRates`() throws -> [Rate]
    func `listFiatCurrencies`() throws -> [FiatCurrency]
    func `listLsps`() throws -> [LspInformation]
    func `connectLsp`(`lspId`: String) throws
    func `fetchLspInfo`(`lspId`: String) throws -> LspInformation?
    func `openChannelFee`(`req`: OpenChannelFeeRequest) throws -> OpenChannelFeeResponse
    func `lspId`() throws -> String?
    func `lspInfo`() throws -> LspInformation
    func `closeLspChannels`() throws
    func `registerWebhook`(`webhookUrl`: String) throws
    func `receiveOnchain`(`req`: ReceiveOnchainRequest) throws -> SwapInfo
    func `inProgressSwap`() throws -> SwapInfo?
    func `listRefundables`() throws -> [SwapInfo]
    func `prepareRefund`(`req`: PrepareRefundRequest) throws -> PrepareRefundResponse
    func `refund`(`req`: RefundRequest) throws -> RefundResponse
    func `fetchReverseSwapFees`(`req`: ReverseSwapFeesRequest) throws -> ReverseSwapPairInfo
    func `inProgressReverseSwaps`() throws -> [ReverseSwapInfo]
    func `maxReverseSwapAmount`() throws -> MaxReverseSwapAmountResponse
    func `sendOnchain`(`req`: SendOnchainRequest) throws -> SendOnchainResponse
    func `serviceHealthCheck`() throws -> ServiceHealthCheckResponse
    func `executeDevCommand`(`command`: String) throws -> String
    func `sync`() throws
    func `recommendedFees`() throws -> RecommendedFees
    func `buyBitcoin`(`req`: BuyBitcoinRequest) throws -> BuyBitcoinResponse
    func `prepareSweep`(`req`: PrepareSweepRequest) throws -> PrepareSweepResponse
    
}

public class BlockingBreezServices: BlockingBreezServicesProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { ffi_breez_sdk_76fc_BlockingBreezServices_object_free(pointer, $0) }
    }

    

    
    public func `disconnect`() throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_disconnect(self.pointer, $0
    )
}
    }
    public func `sendPayment`(`req`: SendPaymentRequest) throws -> SendPaymentResponse {
        return try FfiConverterTypeSendPaymentResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSendPaymentError.self) {
    breez_sdk_76fc_BlockingBreezServices_send_payment(self.pointer,
        FfiConverterTypeSendPaymentRequest.lower(`req`), $0
    )
}
        )
    }
    public func `sendSpontaneousPayment`(`req`: SendSpontaneousPaymentRequest) throws -> SendPaymentResponse {
        return try FfiConverterTypeSendPaymentResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSendPaymentError.self) {
    breez_sdk_76fc_BlockingBreezServices_send_spontaneous_payment(self.pointer,
        FfiConverterTypeSendSpontaneousPaymentRequest.lower(`req`), $0
    )
}
        )
    }
    public func `receivePayment`(`req`: ReceivePaymentRequest) throws -> ReceivePaymentResponse {
        return try FfiConverterTypeReceivePaymentResponse.lift(
            try
    rustCallWithError(FfiConverterTypeReceivePaymentError.self) {
    breez_sdk_76fc_BlockingBreezServices_receive_payment(self.pointer,
        FfiConverterTypeReceivePaymentRequest.lower(`req`), $0
    )
}
        )
    }
    public func `payLnurl`(`req`: LnUrlPayRequest) throws -> LnUrlPayResult {
        return try FfiConverterTypeLnUrlPayResult.lift(
            try
    rustCallWithError(FfiConverterTypeLnUrlPayError.self) {
    breez_sdk_76fc_BlockingBreezServices_pay_lnurl(self.pointer,
        FfiConverterTypeLnUrlPayRequest.lower(`req`), $0
    )
}
        )
    }
    public func `withdrawLnurl`(`request`: LnUrlWithdrawRequest) throws -> LnUrlWithdrawResult {
        return try FfiConverterTypeLnUrlWithdrawResult.lift(
            try
    rustCallWithError(FfiConverterTypeLnUrlWithdrawError.self) {
    breez_sdk_76fc_BlockingBreezServices_withdraw_lnurl(self.pointer,
        FfiConverterTypeLnUrlWithdrawRequest.lower(`request`), $0
    )
}
        )
    }
    public func `lnurlAuth`(`reqData`: LnUrlAuthRequestData) throws -> LnUrlCallbackStatus {
        return try FfiConverterTypeLnUrlCallbackStatus.lift(
            try
    rustCallWithError(FfiConverterTypeLnUrlAuthError.self) {
    breez_sdk_76fc_BlockingBreezServices_lnurl_auth(self.pointer,
        FfiConverterTypeLnUrlAuthRequestData.lower(`reqData`), $0
    )
}
        )
    }
    public func `reportIssue`(`req`: ReportIssueRequest) throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_report_issue(self.pointer,
        FfiConverterTypeReportIssueRequest.lower(`req`), $0
    )
}
    }
    public func `nodeCredentials`() throws -> NodeCredentials? {
        return try FfiConverterOptionTypeNodeCredentials.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_node_credentials(self.pointer, $0
    )
}
        )
    }
    public func `nodeInfo`() throws -> NodeState {
        return try FfiConverterTypeNodeState.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_node_info(self.pointer, $0
    )
}
        )
    }
    public func `signMessage`(`req`: SignMessageRequest) throws -> SignMessageResponse {
        return try FfiConverterTypeSignMessageResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_sign_message(self.pointer,
        FfiConverterTypeSignMessageRequest.lower(`req`), $0
    )
}
        )
    }
    public func `checkMessage`(`req`: CheckMessageRequest) throws -> CheckMessageResponse {
        return try FfiConverterTypeCheckMessageResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_check_message(self.pointer,
        FfiConverterTypeCheckMessageRequest.lower(`req`), $0
    )
}
        )
    }
    public func `backupStatus`() throws -> BackupStatus {
        return try FfiConverterTypeBackupStatus.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_backup_status(self.pointer, $0
    )
}
        )
    }
    public func `backup`() throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_backup(self.pointer, $0
    )
}
    }
    public func `paymentByHash`(`hash`: String) throws -> Payment? {
        return try FfiConverterOptionTypePayment.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_payment_by_hash(self.pointer,
        FfiConverterString.lower(`hash`), $0
    )
}
        )
    }
    public func `listPayments`(`req`: ListPaymentsRequest) throws -> [Payment] {
        return try FfiConverterSequenceTypePayment.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_list_payments(self.pointer,
        FfiConverterTypeListPaymentsRequest.lower(`req`), $0
    )
}
        )
    }
    public func `sweep`(`req`: SweepRequest) throws -> SweepResponse {
        return try FfiConverterTypeSweepResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_sweep(self.pointer,
        FfiConverterTypeSweepRequest.lower(`req`), $0
    )
}
        )
    }
    public func `fetchFiatRates`() throws -> [Rate] {
        return try FfiConverterSequenceTypeRate.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_fetch_fiat_rates(self.pointer, $0
    )
}
        )
    }
    public func `listFiatCurrencies`() throws -> [FiatCurrency] {
        return try FfiConverterSequenceTypeFiatCurrency.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_list_fiat_currencies(self.pointer, $0
    )
}
        )
    }
    public func `listLsps`() throws -> [LspInformation] {
        return try FfiConverterSequenceTypeLspInformation.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_list_lsps(self.pointer, $0
    )
}
        )
    }
    public func `connectLsp`(`lspId`: String) throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_connect_lsp(self.pointer,
        FfiConverterString.lower(`lspId`), $0
    )
}
    }
    public func `fetchLspInfo`(`lspId`: String) throws -> LspInformation? {
        return try FfiConverterOptionTypeLspInformation.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_fetch_lsp_info(self.pointer,
        FfiConverterString.lower(`lspId`), $0
    )
}
        )
    }
    public func `openChannelFee`(`req`: OpenChannelFeeRequest) throws -> OpenChannelFeeResponse {
        return try FfiConverterTypeOpenChannelFeeResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_open_channel_fee(self.pointer,
        FfiConverterTypeOpenChannelFeeRequest.lower(`req`), $0
    )
}
        )
    }
    public func `lspId`() throws -> String? {
        return try FfiConverterOptionString.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_lsp_id(self.pointer, $0
    )
}
        )
    }
    public func `lspInfo`() throws -> LspInformation {
        return try FfiConverterTypeLspInformation.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_lsp_info(self.pointer, $0
    )
}
        )
    }
    public func `closeLspChannels`() throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_close_lsp_channels(self.pointer, $0
    )
}
    }
    public func `registerWebhook`(`webhookUrl`: String) throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_register_webhook(self.pointer,
        FfiConverterString.lower(`webhookUrl`), $0
    )
}
    }
    public func `receiveOnchain`(`req`: ReceiveOnchainRequest) throws -> SwapInfo {
        return try FfiConverterTypeSwapInfo.lift(
            try
    rustCallWithError(FfiConverterTypeReceiveOnchainError.self) {
    breez_sdk_76fc_BlockingBreezServices_receive_onchain(self.pointer,
        FfiConverterTypeReceiveOnchainRequest.lower(`req`), $0
    )
}
        )
    }
    public func `inProgressSwap`() throws -> SwapInfo? {
        return try FfiConverterOptionTypeSwapInfo.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_in_progress_swap(self.pointer, $0
    )
}
        )
    }
    public func `listRefundables`() throws -> [SwapInfo] {
        return try FfiConverterSequenceTypeSwapInfo.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_list_refundables(self.pointer, $0
    )
}
        )
    }
    public func `prepareRefund`(`req`: PrepareRefundRequest) throws -> PrepareRefundResponse {
        return try FfiConverterTypePrepareRefundResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_prepare_refund(self.pointer,
        FfiConverterTypePrepareRefundRequest.lower(`req`), $0
    )
}
        )
    }
    public func `refund`(`req`: RefundRequest) throws -> RefundResponse {
        return try FfiConverterTypeRefundResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_refund(self.pointer,
        FfiConverterTypeRefundRequest.lower(`req`), $0
    )
}
        )
    }
    public func `fetchReverseSwapFees`(`req`: ReverseSwapFeesRequest) throws -> ReverseSwapPairInfo {
        return try FfiConverterTypeReverseSwapPairInfo.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_fetch_reverse_swap_fees(self.pointer,
        FfiConverterTypeReverseSwapFeesRequest.lower(`req`), $0
    )
}
        )
    }
    public func `inProgressReverseSwaps`() throws -> [ReverseSwapInfo] {
        return try FfiConverterSequenceTypeReverseSwapInfo.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_in_progress_reverse_swaps(self.pointer, $0
    )
}
        )
    }
    public func `maxReverseSwapAmount`() throws -> MaxReverseSwapAmountResponse {
        return try FfiConverterTypeMaxReverseSwapAmountResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_max_reverse_swap_amount(self.pointer, $0
    )
}
        )
    }
    public func `sendOnchain`(`req`: SendOnchainRequest) throws -> SendOnchainResponse {
        return try FfiConverterTypeSendOnchainResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSendOnchainError.self) {
    breez_sdk_76fc_BlockingBreezServices_send_onchain(self.pointer,
        FfiConverterTypeSendOnchainRequest.lower(`req`), $0
    )
}
        )
    }
    public func `serviceHealthCheck`() throws -> ServiceHealthCheckResponse {
        return try FfiConverterTypeServiceHealthCheckResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_service_health_check(self.pointer, $0
    )
}
        )
    }
    public func `executeDevCommand`(`command`: String) throws -> String {
        return try FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_execute_dev_command(self.pointer,
        FfiConverterString.lower(`command`), $0
    )
}
        )
    }
    public func `sync`() throws {
        try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_sync(self.pointer, $0
    )
}
    }
    public func `recommendedFees`() throws -> RecommendedFees {
        return try FfiConverterTypeRecommendedFees.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_recommended_fees(self.pointer, $0
    )
}
        )
    }
    public func `buyBitcoin`(`req`: BuyBitcoinRequest) throws -> BuyBitcoinResponse {
        return try FfiConverterTypeBuyBitcoinResponse.lift(
            try
    rustCallWithError(FfiConverterTypeReceiveOnchainError.self) {
    breez_sdk_76fc_BlockingBreezServices_buy_bitcoin(self.pointer,
        FfiConverterTypeBuyBitcoinRequest.lower(`req`), $0
    )
}
        )
    }
    public func `prepareSweep`(`req`: PrepareSweepRequest) throws -> PrepareSweepResponse {
        return try FfiConverterTypePrepareSweepResponse.lift(
            try
    rustCallWithError(FfiConverterTypeSdkError.self) {
    breez_sdk_76fc_BlockingBreezServices_prepare_sweep(self.pointer,
        FfiConverterTypePrepareSweepRequest.lower(`req`), $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeBlockingBreezServices: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlockingBreezServices

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockingBreezServices {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlockingBreezServices, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlockingBreezServices {
        return BlockingBreezServices(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlockingBreezServices) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public struct AesSuccessActionDataDecrypted {
    public var `description`: String
    public var `plaintext`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`description`: String, `plaintext`: String) {
        self.`description` = `description`
        self.`plaintext` = `plaintext`
    }
}


extension AesSuccessActionDataDecrypted: Equatable, Hashable {
    public static func ==(lhs: AesSuccessActionDataDecrypted, rhs: AesSuccessActionDataDecrypted) -> Bool {
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`plaintext` != rhs.`plaintext` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`description`)
        hasher.combine(`plaintext`)
    }
}


public struct FfiConverterTypeAesSuccessActionDataDecrypted: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataDecrypted {
        return try AesSuccessActionDataDecrypted(
            `description`: FfiConverterString.read(from: &buf),
            `plaintext`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AesSuccessActionDataDecrypted, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`description`, into: &buf)
        FfiConverterString.write(value.`plaintext`, into: &buf)
    }
}


public func FfiConverterTypeAesSuccessActionDataDecrypted_lift(_ buf: RustBuffer) throws -> AesSuccessActionDataDecrypted {
    return try FfiConverterTypeAesSuccessActionDataDecrypted.lift(buf)
}

public func FfiConverterTypeAesSuccessActionDataDecrypted_lower(_ value: AesSuccessActionDataDecrypted) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionDataDecrypted.lower(value)
}


public struct BackupFailedData {
    public var `error`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`error`: String) {
        self.`error` = `error`
    }
}


extension BackupFailedData: Equatable, Hashable {
    public static func ==(lhs: BackupFailedData, rhs: BackupFailedData) -> Bool {
        if lhs.`error` != rhs.`error` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`error`)
    }
}


public struct FfiConverterTypeBackupFailedData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupFailedData {
        return try BackupFailedData(
            `error`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: BackupFailedData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`error`, into: &buf)
    }
}


public func FfiConverterTypeBackupFailedData_lift(_ buf: RustBuffer) throws -> BackupFailedData {
    return try FfiConverterTypeBackupFailedData.lift(buf)
}

public func FfiConverterTypeBackupFailedData_lower(_ value: BackupFailedData) -> RustBuffer {
    return FfiConverterTypeBackupFailedData.lower(value)
}


public struct BackupStatus {
    public var `backedUp`: Bool
    public var `lastBackupTime`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`backedUp`: Bool, `lastBackupTime`: UInt64?) {
        self.`backedUp` = `backedUp`
        self.`lastBackupTime` = `lastBackupTime`
    }
}


extension BackupStatus: Equatable, Hashable {
    public static func ==(lhs: BackupStatus, rhs: BackupStatus) -> Bool {
        if lhs.`backedUp` != rhs.`backedUp` {
            return false
        }
        if lhs.`lastBackupTime` != rhs.`lastBackupTime` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`backedUp`)
        hasher.combine(`lastBackupTime`)
    }
}


public struct FfiConverterTypeBackupStatus: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupStatus {
        return try BackupStatus(
            `backedUp`: FfiConverterBool.read(from: &buf),
            `lastBackupTime`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BackupStatus, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`backedUp`, into: &buf)
        FfiConverterOptionUInt64.write(value.`lastBackupTime`, into: &buf)
    }
}


public func FfiConverterTypeBackupStatus_lift(_ buf: RustBuffer) throws -> BackupStatus {
    return try FfiConverterTypeBackupStatus.lift(buf)
}

public func FfiConverterTypeBackupStatus_lower(_ value: BackupStatus) -> RustBuffer {
    return FfiConverterTypeBackupStatus.lower(value)
}


public struct BitcoinAddressData {
    public var `address`: String
    public var `network`: Network
    public var `amountSat`: UInt64?
    public var `label`: String?
    public var `message`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`address`: String, `network`: Network, `amountSat`: UInt64?, `label`: String?, `message`: String?) {
        self.`address` = `address`
        self.`network` = `network`
        self.`amountSat` = `amountSat`
        self.`label` = `label`
        self.`message` = `message`
    }
}


extension BitcoinAddressData: Equatable, Hashable {
    public static func ==(lhs: BitcoinAddressData, rhs: BitcoinAddressData) -> Bool {
        if lhs.`address` != rhs.`address` {
            return false
        }
        if lhs.`network` != rhs.`network` {
            return false
        }
        if lhs.`amountSat` != rhs.`amountSat` {
            return false
        }
        if lhs.`label` != rhs.`label` {
            return false
        }
        if lhs.`message` != rhs.`message` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`address`)
        hasher.combine(`network`)
        hasher.combine(`amountSat`)
        hasher.combine(`label`)
        hasher.combine(`message`)
    }
}


public struct FfiConverterTypeBitcoinAddressData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinAddressData {
        return try BitcoinAddressData(
            `address`: FfiConverterString.read(from: &buf),
            `network`: FfiConverterTypeNetwork.read(from: &buf),
            `amountSat`: FfiConverterOptionUInt64.read(from: &buf),
            `label`: FfiConverterOptionString.read(from: &buf),
            `message`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: BitcoinAddressData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`address`, into: &buf)
        FfiConverterTypeNetwork.write(value.`network`, into: &buf)
        FfiConverterOptionUInt64.write(value.`amountSat`, into: &buf)
        FfiConverterOptionString.write(value.`label`, into: &buf)
        FfiConverterOptionString.write(value.`message`, into: &buf)
    }
}


public func FfiConverterTypeBitcoinAddressData_lift(_ buf: RustBuffer) throws -> BitcoinAddressData {
    return try FfiConverterTypeBitcoinAddressData.lift(buf)
}

public func FfiConverterTypeBitcoinAddressData_lower(_ value: BitcoinAddressData) -> RustBuffer {
    return FfiConverterTypeBitcoinAddressData.lower(value)
}


public struct BuyBitcoinRequest {
    public var `provider`: BuyBitcoinProvider
    public var `openingFeeParams`: OpeningFeeParams?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`provider`: BuyBitcoinProvider, `openingFeeParams`: OpeningFeeParams? = nil) {
        self.`provider` = `provider`
        self.`openingFeeParams` = `openingFeeParams`
    }
}


extension BuyBitcoinRequest: Equatable, Hashable {
    public static func ==(lhs: BuyBitcoinRequest, rhs: BuyBitcoinRequest) -> Bool {
        if lhs.`provider` != rhs.`provider` {
            return false
        }
        if lhs.`openingFeeParams` != rhs.`openingFeeParams` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`provider`)
        hasher.combine(`openingFeeParams`)
    }
}


public struct FfiConverterTypeBuyBitcoinRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuyBitcoinRequest {
        return try BuyBitcoinRequest(
            `provider`: FfiConverterTypeBuyBitcoinProvider.read(from: &buf),
            `openingFeeParams`: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf)
        )
    }

    public static func write(_ value: BuyBitcoinRequest, into buf: inout [UInt8]) {
        FfiConverterTypeBuyBitcoinProvider.write(value.`provider`, into: &buf)
        FfiConverterOptionTypeOpeningFeeParams.write(value.`openingFeeParams`, into: &buf)
    }
}


public func FfiConverterTypeBuyBitcoinRequest_lift(_ buf: RustBuffer) throws -> BuyBitcoinRequest {
    return try FfiConverterTypeBuyBitcoinRequest.lift(buf)
}

public func FfiConverterTypeBuyBitcoinRequest_lower(_ value: BuyBitcoinRequest) -> RustBuffer {
    return FfiConverterTypeBuyBitcoinRequest.lower(value)
}


public struct BuyBitcoinResponse {
    public var `url`: String
    public var `openingFeeParams`: OpeningFeeParams?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`url`: String, `openingFeeParams`: OpeningFeeParams?) {
        self.`url` = `url`
        self.`openingFeeParams` = `openingFeeParams`
    }
}


extension BuyBitcoinResponse: Equatable, Hashable {
    public static func ==(lhs: BuyBitcoinResponse, rhs: BuyBitcoinResponse) -> Bool {
        if lhs.`url` != rhs.`url` {
            return false
        }
        if lhs.`openingFeeParams` != rhs.`openingFeeParams` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`url`)
        hasher.combine(`openingFeeParams`)
    }
}


public struct FfiConverterTypeBuyBitcoinResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuyBitcoinResponse {
        return try BuyBitcoinResponse(
            `url`: FfiConverterString.read(from: &buf),
            `openingFeeParams`: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf)
        )
    }

    public static func write(_ value: BuyBitcoinResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`url`, into: &buf)
        FfiConverterOptionTypeOpeningFeeParams.write(value.`openingFeeParams`, into: &buf)
    }
}


public func FfiConverterTypeBuyBitcoinResponse_lift(_ buf: RustBuffer) throws -> BuyBitcoinResponse {
    return try FfiConverterTypeBuyBitcoinResponse.lift(buf)
}

public func FfiConverterTypeBuyBitcoinResponse_lower(_ value: BuyBitcoinResponse) -> RustBuffer {
    return FfiConverterTypeBuyBitcoinResponse.lower(value)
}


public struct CheckMessageRequest {
    public var `message`: String
    public var `pubkey`: String
    public var `signature`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`message`: String, `pubkey`: String, `signature`: String) {
        self.`message` = `message`
        self.`pubkey` = `pubkey`
        self.`signature` = `signature`
    }
}


extension CheckMessageRequest: Equatable, Hashable {
    public static func ==(lhs: CheckMessageRequest, rhs: CheckMessageRequest) -> Bool {
        if lhs.`message` != rhs.`message` {
            return false
        }
        if lhs.`pubkey` != rhs.`pubkey` {
            return false
        }
        if lhs.`signature` != rhs.`signature` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`message`)
        hasher.combine(`pubkey`)
        hasher.combine(`signature`)
    }
}


public struct FfiConverterTypeCheckMessageRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckMessageRequest {
        return try CheckMessageRequest(
            `message`: FfiConverterString.read(from: &buf),
            `pubkey`: FfiConverterString.read(from: &buf),
            `signature`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CheckMessageRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`message`, into: &buf)
        FfiConverterString.write(value.`pubkey`, into: &buf)
        FfiConverterString.write(value.`signature`, into: &buf)
    }
}


public func FfiConverterTypeCheckMessageRequest_lift(_ buf: RustBuffer) throws -> CheckMessageRequest {
    return try FfiConverterTypeCheckMessageRequest.lift(buf)
}

public func FfiConverterTypeCheckMessageRequest_lower(_ value: CheckMessageRequest) -> RustBuffer {
    return FfiConverterTypeCheckMessageRequest.lower(value)
}


public struct CheckMessageResponse {
    public var `isValid`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`isValid`: Bool) {
        self.`isValid` = `isValid`
    }
}


extension CheckMessageResponse: Equatable, Hashable {
    public static func ==(lhs: CheckMessageResponse, rhs: CheckMessageResponse) -> Bool {
        if lhs.`isValid` != rhs.`isValid` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`isValid`)
    }
}


public struct FfiConverterTypeCheckMessageResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckMessageResponse {
        return try CheckMessageResponse(
            `isValid`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CheckMessageResponse, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`isValid`, into: &buf)
    }
}


public func FfiConverterTypeCheckMessageResponse_lift(_ buf: RustBuffer) throws -> CheckMessageResponse {
    return try FfiConverterTypeCheckMessageResponse.lift(buf)
}

public func FfiConverterTypeCheckMessageResponse_lower(_ value: CheckMessageResponse) -> RustBuffer {
    return FfiConverterTypeCheckMessageResponse.lower(value)
}


public struct ClosedChannelPaymentDetails {
    public var `shortChannelId`: String
    public var `state`: ChannelState
    public var `fundingTxid`: String
    public var `closingTxid`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`shortChannelId`: String, `state`: ChannelState, `fundingTxid`: String, `closingTxid`: String?) {
        self.`shortChannelId` = `shortChannelId`
        self.`state` = `state`
        self.`fundingTxid` = `fundingTxid`
        self.`closingTxid` = `closingTxid`
    }
}


extension ClosedChannelPaymentDetails: Equatable, Hashable {
    public static func ==(lhs: ClosedChannelPaymentDetails, rhs: ClosedChannelPaymentDetails) -> Bool {
        if lhs.`shortChannelId` != rhs.`shortChannelId` {
            return false
        }
        if lhs.`state` != rhs.`state` {
            return false
        }
        if lhs.`fundingTxid` != rhs.`fundingTxid` {
            return false
        }
        if lhs.`closingTxid` != rhs.`closingTxid` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`shortChannelId`)
        hasher.combine(`state`)
        hasher.combine(`fundingTxid`)
        hasher.combine(`closingTxid`)
    }
}


public struct FfiConverterTypeClosedChannelPaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClosedChannelPaymentDetails {
        return try ClosedChannelPaymentDetails(
            `shortChannelId`: FfiConverterString.read(from: &buf),
            `state`: FfiConverterTypeChannelState.read(from: &buf),
            `fundingTxid`: FfiConverterString.read(from: &buf),
            `closingTxid`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ClosedChannelPaymentDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`shortChannelId`, into: &buf)
        FfiConverterTypeChannelState.write(value.`state`, into: &buf)
        FfiConverterString.write(value.`fundingTxid`, into: &buf)
        FfiConverterOptionString.write(value.`closingTxid`, into: &buf)
    }
}


public func FfiConverterTypeClosedChannelPaymentDetails_lift(_ buf: RustBuffer) throws -> ClosedChannelPaymentDetails {
    return try FfiConverterTypeClosedChannelPaymentDetails.lift(buf)
}

public func FfiConverterTypeClosedChannelPaymentDetails_lower(_ value: ClosedChannelPaymentDetails) -> RustBuffer {
    return FfiConverterTypeClosedChannelPaymentDetails.lower(value)
}


public struct Config {
    public var `breezserver`: String
    public var `mempoolspaceUrl`: String
    public var `workingDir`: String
    public var `network`: Network
    public var `paymentTimeoutSec`: UInt32
    public var `defaultLspId`: String?
    public var `apiKey`: String?
    public var `maxfeePercent`: Double
    public var `exemptfeeMsat`: UInt64
    public var `nodeConfig`: NodeConfig

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`breezserver`: String, `mempoolspaceUrl`: String, `workingDir`: String, `network`: Network, `paymentTimeoutSec`: UInt32, `defaultLspId`: String?, `apiKey`: String?, `maxfeePercent`: Double, `exemptfeeMsat`: UInt64, `nodeConfig`: NodeConfig) {
        self.`breezserver` = `breezserver`
        self.`mempoolspaceUrl` = `mempoolspaceUrl`
        self.`workingDir` = `workingDir`
        self.`network` = `network`
        self.`paymentTimeoutSec` = `paymentTimeoutSec`
        self.`defaultLspId` = `defaultLspId`
        self.`apiKey` = `apiKey`
        self.`maxfeePercent` = `maxfeePercent`
        self.`exemptfeeMsat` = `exemptfeeMsat`
        self.`nodeConfig` = `nodeConfig`
    }
}


extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.`breezserver` != rhs.`breezserver` {
            return false
        }
        if lhs.`mempoolspaceUrl` != rhs.`mempoolspaceUrl` {
            return false
        }
        if lhs.`workingDir` != rhs.`workingDir` {
            return false
        }
        if lhs.`network` != rhs.`network` {
            return false
        }
        if lhs.`paymentTimeoutSec` != rhs.`paymentTimeoutSec` {
            return false
        }
        if lhs.`defaultLspId` != rhs.`defaultLspId` {
            return false
        }
        if lhs.`apiKey` != rhs.`apiKey` {
            return false
        }
        if lhs.`maxfeePercent` != rhs.`maxfeePercent` {
            return false
        }
        if lhs.`exemptfeeMsat` != rhs.`exemptfeeMsat` {
            return false
        }
        if lhs.`nodeConfig` != rhs.`nodeConfig` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`breezserver`)
        hasher.combine(`mempoolspaceUrl`)
        hasher.combine(`workingDir`)
        hasher.combine(`network`)
        hasher.combine(`paymentTimeoutSec`)
        hasher.combine(`defaultLspId`)
        hasher.combine(`apiKey`)
        hasher.combine(`maxfeePercent`)
        hasher.combine(`exemptfeeMsat`)
        hasher.combine(`nodeConfig`)
    }
}


public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return try Config(
            `breezserver`: FfiConverterString.read(from: &buf),
            `mempoolspaceUrl`: FfiConverterString.read(from: &buf),
            `workingDir`: FfiConverterString.read(from: &buf),
            `network`: FfiConverterTypeNetwork.read(from: &buf),
            `paymentTimeoutSec`: FfiConverterUInt32.read(from: &buf),
            `defaultLspId`: FfiConverterOptionString.read(from: &buf),
            `apiKey`: FfiConverterOptionString.read(from: &buf),
            `maxfeePercent`: FfiConverterDouble.read(from: &buf),
            `exemptfeeMsat`: FfiConverterUInt64.read(from: &buf),
            `nodeConfig`: FfiConverterTypeNodeConfig.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`breezserver`, into: &buf)
        FfiConverterString.write(value.`mempoolspaceUrl`, into: &buf)
        FfiConverterString.write(value.`workingDir`, into: &buf)
        FfiConverterTypeNetwork.write(value.`network`, into: &buf)
        FfiConverterUInt32.write(value.`paymentTimeoutSec`, into: &buf)
        FfiConverterOptionString.write(value.`defaultLspId`, into: &buf)
        FfiConverterOptionString.write(value.`apiKey`, into: &buf)
        FfiConverterDouble.write(value.`maxfeePercent`, into: &buf)
        FfiConverterUInt64.write(value.`exemptfeeMsat`, into: &buf)
        FfiConverterTypeNodeConfig.write(value.`nodeConfig`, into: &buf)
    }
}


public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct CurrencyInfo {
    public var `name`: String
    public var `fractionSize`: UInt32
    public var `spacing`: UInt32?
    public var `symbol`: Symbol?
    public var `uniqSymbol`: Symbol?
    public var `localizedName`: [LocalizedName]?
    public var `localeOverrides`: [LocaleOverrides]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `fractionSize`: UInt32, `spacing`: UInt32?, `symbol`: Symbol?, `uniqSymbol`: Symbol?, `localizedName`: [LocalizedName]?, `localeOverrides`: [LocaleOverrides]?) {
        self.`name` = `name`
        self.`fractionSize` = `fractionSize`
        self.`spacing` = `spacing`
        self.`symbol` = `symbol`
        self.`uniqSymbol` = `uniqSymbol`
        self.`localizedName` = `localizedName`
        self.`localeOverrides` = `localeOverrides`
    }
}


extension CurrencyInfo: Equatable, Hashable {
    public static func ==(lhs: CurrencyInfo, rhs: CurrencyInfo) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`fractionSize` != rhs.`fractionSize` {
            return false
        }
        if lhs.`spacing` != rhs.`spacing` {
            return false
        }
        if lhs.`symbol` != rhs.`symbol` {
            return false
        }
        if lhs.`uniqSymbol` != rhs.`uniqSymbol` {
            return false
        }
        if lhs.`localizedName` != rhs.`localizedName` {
            return false
        }
        if lhs.`localeOverrides` != rhs.`localeOverrides` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`fractionSize`)
        hasher.combine(`spacing`)
        hasher.combine(`symbol`)
        hasher.combine(`uniqSymbol`)
        hasher.combine(`localizedName`)
        hasher.combine(`localeOverrides`)
    }
}


public struct FfiConverterTypeCurrencyInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CurrencyInfo {
        return try CurrencyInfo(
            `name`: FfiConverterString.read(from: &buf),
            `fractionSize`: FfiConverterUInt32.read(from: &buf),
            `spacing`: FfiConverterOptionUInt32.read(from: &buf),
            `symbol`: FfiConverterOptionTypeSymbol.read(from: &buf),
            `uniqSymbol`: FfiConverterOptionTypeSymbol.read(from: &buf),
            `localizedName`: FfiConverterOptionSequenceTypeLocalizedName.read(from: &buf),
            `localeOverrides`: FfiConverterOptionSequenceTypeLocaleOverrides.read(from: &buf)
        )
    }

    public static func write(_ value: CurrencyInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterUInt32.write(value.`fractionSize`, into: &buf)
        FfiConverterOptionUInt32.write(value.`spacing`, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.`symbol`, into: &buf)
        FfiConverterOptionTypeSymbol.write(value.`uniqSymbol`, into: &buf)
        FfiConverterOptionSequenceTypeLocalizedName.write(value.`localizedName`, into: &buf)
        FfiConverterOptionSequenceTypeLocaleOverrides.write(value.`localeOverrides`, into: &buf)
    }
}


public func FfiConverterTypeCurrencyInfo_lift(_ buf: RustBuffer) throws -> CurrencyInfo {
    return try FfiConverterTypeCurrencyInfo.lift(buf)
}

public func FfiConverterTypeCurrencyInfo_lower(_ value: CurrencyInfo) -> RustBuffer {
    return FfiConverterTypeCurrencyInfo.lower(value)
}


public struct FiatCurrency {
    public var `id`: String
    public var `info`: CurrencyInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `info`: CurrencyInfo) {
        self.`id` = `id`
        self.`info` = `info`
    }
}


extension FiatCurrency: Equatable, Hashable {
    public static func ==(lhs: FiatCurrency, rhs: FiatCurrency) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`info` != rhs.`info` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`info`)
    }
}


public struct FfiConverterTypeFiatCurrency: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FiatCurrency {
        return try FiatCurrency(
            `id`: FfiConverterString.read(from: &buf),
            `info`: FfiConverterTypeCurrencyInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FiatCurrency, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterTypeCurrencyInfo.write(value.`info`, into: &buf)
    }
}


public func FfiConverterTypeFiatCurrency_lift(_ buf: RustBuffer) throws -> FiatCurrency {
    return try FfiConverterTypeFiatCurrency.lift(buf)
}

public func FfiConverterTypeFiatCurrency_lower(_ value: FiatCurrency) -> RustBuffer {
    return FfiConverterTypeFiatCurrency.lower(value)
}


public struct GreenlightCredentials {
    public var `deviceKey`: [UInt8]
    public var `deviceCert`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`deviceKey`: [UInt8], `deviceCert`: [UInt8]) {
        self.`deviceKey` = `deviceKey`
        self.`deviceCert` = `deviceCert`
    }
}


extension GreenlightCredentials: Equatable, Hashable {
    public static func ==(lhs: GreenlightCredentials, rhs: GreenlightCredentials) -> Bool {
        if lhs.`deviceKey` != rhs.`deviceKey` {
            return false
        }
        if lhs.`deviceCert` != rhs.`deviceCert` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`deviceKey`)
        hasher.combine(`deviceCert`)
    }
}


public struct FfiConverterTypeGreenlightCredentials: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GreenlightCredentials {
        return try GreenlightCredentials(
            `deviceKey`: FfiConverterSequenceUInt8.read(from: &buf),
            `deviceCert`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: GreenlightCredentials, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.`deviceKey`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`deviceCert`, into: &buf)
    }
}


public func FfiConverterTypeGreenlightCredentials_lift(_ buf: RustBuffer) throws -> GreenlightCredentials {
    return try FfiConverterTypeGreenlightCredentials.lift(buf)
}

public func FfiConverterTypeGreenlightCredentials_lower(_ value: GreenlightCredentials) -> RustBuffer {
    return FfiConverterTypeGreenlightCredentials.lower(value)
}


public struct GreenlightNodeConfig {
    public var `partnerCredentials`: GreenlightCredentials?
    public var `inviteCode`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`partnerCredentials`: GreenlightCredentials?, `inviteCode`: String?) {
        self.`partnerCredentials` = `partnerCredentials`
        self.`inviteCode` = `inviteCode`
    }
}


extension GreenlightNodeConfig: Equatable, Hashable {
    public static func ==(lhs: GreenlightNodeConfig, rhs: GreenlightNodeConfig) -> Bool {
        if lhs.`partnerCredentials` != rhs.`partnerCredentials` {
            return false
        }
        if lhs.`inviteCode` != rhs.`inviteCode` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`partnerCredentials`)
        hasher.combine(`inviteCode`)
    }
}


public struct FfiConverterTypeGreenlightNodeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GreenlightNodeConfig {
        return try GreenlightNodeConfig(
            `partnerCredentials`: FfiConverterOptionTypeGreenlightCredentials.read(from: &buf),
            `inviteCode`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: GreenlightNodeConfig, into buf: inout [UInt8]) {
        FfiConverterOptionTypeGreenlightCredentials.write(value.`partnerCredentials`, into: &buf)
        FfiConverterOptionString.write(value.`inviteCode`, into: &buf)
    }
}


public func FfiConverterTypeGreenlightNodeConfig_lift(_ buf: RustBuffer) throws -> GreenlightNodeConfig {
    return try FfiConverterTypeGreenlightNodeConfig.lift(buf)
}

public func FfiConverterTypeGreenlightNodeConfig_lower(_ value: GreenlightNodeConfig) -> RustBuffer {
    return FfiConverterTypeGreenlightNodeConfig.lower(value)
}


public struct InvoicePaidDetails {
    public var `paymentHash`: String
    public var `bolt11`: String
    public var `payment`: Payment?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`paymentHash`: String, `bolt11`: String, `payment`: Payment?) {
        self.`paymentHash` = `paymentHash`
        self.`bolt11` = `bolt11`
        self.`payment` = `payment`
    }
}


extension InvoicePaidDetails: Equatable, Hashable {
    public static func ==(lhs: InvoicePaidDetails, rhs: InvoicePaidDetails) -> Bool {
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`bolt11` != rhs.`bolt11` {
            return false
        }
        if lhs.`payment` != rhs.`payment` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`paymentHash`)
        hasher.combine(`bolt11`)
        hasher.combine(`payment`)
    }
}


public struct FfiConverterTypeInvoicePaidDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoicePaidDetails {
        return try InvoicePaidDetails(
            `paymentHash`: FfiConverterString.read(from: &buf),
            `bolt11`: FfiConverterString.read(from: &buf),
            `payment`: FfiConverterOptionTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: InvoicePaidDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`paymentHash`, into: &buf)
        FfiConverterString.write(value.`bolt11`, into: &buf)
        FfiConverterOptionTypePayment.write(value.`payment`, into: &buf)
    }
}


public func FfiConverterTypeInvoicePaidDetails_lift(_ buf: RustBuffer) throws -> InvoicePaidDetails {
    return try FfiConverterTypeInvoicePaidDetails.lift(buf)
}

public func FfiConverterTypeInvoicePaidDetails_lower(_ value: InvoicePaidDetails) -> RustBuffer {
    return FfiConverterTypeInvoicePaidDetails.lower(value)
}


public struct LnInvoice {
    public var `bolt11`: String
    public var `network`: Network
    public var `payeePubkey`: String
    public var `paymentHash`: String
    public var `description`: String?
    public var `descriptionHash`: String?
    public var `amountMsat`: UInt64?
    public var `timestamp`: UInt64
    public var `expiry`: UInt64
    public var `routingHints`: [RouteHint]
    public var `paymentSecret`: [UInt8]
    public var `minFinalCltvExpiryDelta`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`bolt11`: String, `network`: Network, `payeePubkey`: String, `paymentHash`: String, `description`: String?, `descriptionHash`: String?, `amountMsat`: UInt64?, `timestamp`: UInt64, `expiry`: UInt64, `routingHints`: [RouteHint], `paymentSecret`: [UInt8], `minFinalCltvExpiryDelta`: UInt64) {
        self.`bolt11` = `bolt11`
        self.`network` = `network`
        self.`payeePubkey` = `payeePubkey`
        self.`paymentHash` = `paymentHash`
        self.`description` = `description`
        self.`descriptionHash` = `descriptionHash`
        self.`amountMsat` = `amountMsat`
        self.`timestamp` = `timestamp`
        self.`expiry` = `expiry`
        self.`routingHints` = `routingHints`
        self.`paymentSecret` = `paymentSecret`
        self.`minFinalCltvExpiryDelta` = `minFinalCltvExpiryDelta`
    }
}


extension LnInvoice: Equatable, Hashable {
    public static func ==(lhs: LnInvoice, rhs: LnInvoice) -> Bool {
        if lhs.`bolt11` != rhs.`bolt11` {
            return false
        }
        if lhs.`network` != rhs.`network` {
            return false
        }
        if lhs.`payeePubkey` != rhs.`payeePubkey` {
            return false
        }
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`descriptionHash` != rhs.`descriptionHash` {
            return false
        }
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        if lhs.`expiry` != rhs.`expiry` {
            return false
        }
        if lhs.`routingHints` != rhs.`routingHints` {
            return false
        }
        if lhs.`paymentSecret` != rhs.`paymentSecret` {
            return false
        }
        if lhs.`minFinalCltvExpiryDelta` != rhs.`minFinalCltvExpiryDelta` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`bolt11`)
        hasher.combine(`network`)
        hasher.combine(`payeePubkey`)
        hasher.combine(`paymentHash`)
        hasher.combine(`description`)
        hasher.combine(`descriptionHash`)
        hasher.combine(`amountMsat`)
        hasher.combine(`timestamp`)
        hasher.combine(`expiry`)
        hasher.combine(`routingHints`)
        hasher.combine(`paymentSecret`)
        hasher.combine(`minFinalCltvExpiryDelta`)
    }
}


public struct FfiConverterTypeLnInvoice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnInvoice {
        return try LnInvoice(
            `bolt11`: FfiConverterString.read(from: &buf),
            `network`: FfiConverterTypeNetwork.read(from: &buf),
            `payeePubkey`: FfiConverterString.read(from: &buf),
            `paymentHash`: FfiConverterString.read(from: &buf),
            `description`: FfiConverterOptionString.read(from: &buf),
            `descriptionHash`: FfiConverterOptionString.read(from: &buf),
            `amountMsat`: FfiConverterOptionUInt64.read(from: &buf),
            `timestamp`: FfiConverterUInt64.read(from: &buf),
            `expiry`: FfiConverterUInt64.read(from: &buf),
            `routingHints`: FfiConverterSequenceTypeRouteHint.read(from: &buf),
            `paymentSecret`: FfiConverterSequenceUInt8.read(from: &buf),
            `minFinalCltvExpiryDelta`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LnInvoice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`bolt11`, into: &buf)
        FfiConverterTypeNetwork.write(value.`network`, into: &buf)
        FfiConverterString.write(value.`payeePubkey`, into: &buf)
        FfiConverterString.write(value.`paymentHash`, into: &buf)
        FfiConverterOptionString.write(value.`description`, into: &buf)
        FfiConverterOptionString.write(value.`descriptionHash`, into: &buf)
        FfiConverterOptionUInt64.write(value.`amountMsat`, into: &buf)
        FfiConverterUInt64.write(value.`timestamp`, into: &buf)
        FfiConverterUInt64.write(value.`expiry`, into: &buf)
        FfiConverterSequenceTypeRouteHint.write(value.`routingHints`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`paymentSecret`, into: &buf)
        FfiConverterUInt64.write(value.`minFinalCltvExpiryDelta`, into: &buf)
    }
}


public func FfiConverterTypeLnInvoice_lift(_ buf: RustBuffer) throws -> LnInvoice {
    return try FfiConverterTypeLnInvoice.lift(buf)
}

public func FfiConverterTypeLnInvoice_lower(_ value: LnInvoice) -> RustBuffer {
    return FfiConverterTypeLnInvoice.lower(value)
}


public struct ListPaymentsRequest {
    public var `filters`: [PaymentTypeFilter]?
    public var `fromTimestamp`: Int64?
    public var `toTimestamp`: Int64?
    public var `includeFailures`: Bool?
    public var `offset`: UInt32?
    public var `limit`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`filters`: [PaymentTypeFilter]? = nil, `fromTimestamp`: Int64? = nil, `toTimestamp`: Int64? = nil, `includeFailures`: Bool? = nil, `offset`: UInt32? = nil, `limit`: UInt32? = nil) {
        self.`filters` = `filters`
        self.`fromTimestamp` = `fromTimestamp`
        self.`toTimestamp` = `toTimestamp`
        self.`includeFailures` = `includeFailures`
        self.`offset` = `offset`
        self.`limit` = `limit`
    }
}


extension ListPaymentsRequest: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsRequest, rhs: ListPaymentsRequest) -> Bool {
        if lhs.`filters` != rhs.`filters` {
            return false
        }
        if lhs.`fromTimestamp` != rhs.`fromTimestamp` {
            return false
        }
        if lhs.`toTimestamp` != rhs.`toTimestamp` {
            return false
        }
        if lhs.`includeFailures` != rhs.`includeFailures` {
            return false
        }
        if lhs.`offset` != rhs.`offset` {
            return false
        }
        if lhs.`limit` != rhs.`limit` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`filters`)
        hasher.combine(`fromTimestamp`)
        hasher.combine(`toTimestamp`)
        hasher.combine(`includeFailures`)
        hasher.combine(`offset`)
        hasher.combine(`limit`)
    }
}


public struct FfiConverterTypeListPaymentsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsRequest {
        return try ListPaymentsRequest(
            `filters`: FfiConverterOptionSequenceTypePaymentTypeFilter.read(from: &buf),
            `fromTimestamp`: FfiConverterOptionInt64.read(from: &buf),
            `toTimestamp`: FfiConverterOptionInt64.read(from: &buf),
            `includeFailures`: FfiConverterOptionBool.read(from: &buf),
            `offset`: FfiConverterOptionUInt32.read(from: &buf),
            `limit`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsRequest, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypePaymentTypeFilter.write(value.`filters`, into: &buf)
        FfiConverterOptionInt64.write(value.`fromTimestamp`, into: &buf)
        FfiConverterOptionInt64.write(value.`toTimestamp`, into: &buf)
        FfiConverterOptionBool.write(value.`includeFailures`, into: &buf)
        FfiConverterOptionUInt32.write(value.`offset`, into: &buf)
        FfiConverterOptionUInt32.write(value.`limit`, into: &buf)
    }
}


public func FfiConverterTypeListPaymentsRequest_lift(_ buf: RustBuffer) throws -> ListPaymentsRequest {
    return try FfiConverterTypeListPaymentsRequest.lift(buf)
}

public func FfiConverterTypeListPaymentsRequest_lower(_ value: ListPaymentsRequest) -> RustBuffer {
    return FfiConverterTypeListPaymentsRequest.lower(value)
}


public struct LnPaymentDetails {
    public var `paymentHash`: String
    public var `label`: String
    public var `destinationPubkey`: String
    public var `paymentPreimage`: String
    public var `keysend`: Bool
    public var `bolt11`: String
    public var `lnurlSuccessAction`: SuccessActionProcessed?
    public var `lnurlMetadata`: String?
    public var `lnAddress`: String?
    public var `lnurlWithdrawEndpoint`: String?
    public var `swapInfo`: SwapInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`paymentHash`: String, `label`: String, `destinationPubkey`: String, `paymentPreimage`: String, `keysend`: Bool, `bolt11`: String, `lnurlSuccessAction`: SuccessActionProcessed?, `lnurlMetadata`: String?, `lnAddress`: String?, `lnurlWithdrawEndpoint`: String?, `swapInfo`: SwapInfo?) {
        self.`paymentHash` = `paymentHash`
        self.`label` = `label`
        self.`destinationPubkey` = `destinationPubkey`
        self.`paymentPreimage` = `paymentPreimage`
        self.`keysend` = `keysend`
        self.`bolt11` = `bolt11`
        self.`lnurlSuccessAction` = `lnurlSuccessAction`
        self.`lnurlMetadata` = `lnurlMetadata`
        self.`lnAddress` = `lnAddress`
        self.`lnurlWithdrawEndpoint` = `lnurlWithdrawEndpoint`
        self.`swapInfo` = `swapInfo`
    }
}


extension LnPaymentDetails: Equatable, Hashable {
    public static func ==(lhs: LnPaymentDetails, rhs: LnPaymentDetails) -> Bool {
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`label` != rhs.`label` {
            return false
        }
        if lhs.`destinationPubkey` != rhs.`destinationPubkey` {
            return false
        }
        if lhs.`paymentPreimage` != rhs.`paymentPreimage` {
            return false
        }
        if lhs.`keysend` != rhs.`keysend` {
            return false
        }
        if lhs.`bolt11` != rhs.`bolt11` {
            return false
        }
        if lhs.`lnurlSuccessAction` != rhs.`lnurlSuccessAction` {
            return false
        }
        if lhs.`lnurlMetadata` != rhs.`lnurlMetadata` {
            return false
        }
        if lhs.`lnAddress` != rhs.`lnAddress` {
            return false
        }
        if lhs.`lnurlWithdrawEndpoint` != rhs.`lnurlWithdrawEndpoint` {
            return false
        }
        if lhs.`swapInfo` != rhs.`swapInfo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`paymentHash`)
        hasher.combine(`label`)
        hasher.combine(`destinationPubkey`)
        hasher.combine(`paymentPreimage`)
        hasher.combine(`keysend`)
        hasher.combine(`bolt11`)
        hasher.combine(`lnurlSuccessAction`)
        hasher.combine(`lnurlMetadata`)
        hasher.combine(`lnAddress`)
        hasher.combine(`lnurlWithdrawEndpoint`)
        hasher.combine(`swapInfo`)
    }
}


public struct FfiConverterTypeLnPaymentDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnPaymentDetails {
        return try LnPaymentDetails(
            `paymentHash`: FfiConverterString.read(from: &buf),
            `label`: FfiConverterString.read(from: &buf),
            `destinationPubkey`: FfiConverterString.read(from: &buf),
            `paymentPreimage`: FfiConverterString.read(from: &buf),
            `keysend`: FfiConverterBool.read(from: &buf),
            `bolt11`: FfiConverterString.read(from: &buf),
            `lnurlSuccessAction`: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf),
            `lnurlMetadata`: FfiConverterOptionString.read(from: &buf),
            `lnAddress`: FfiConverterOptionString.read(from: &buf),
            `lnurlWithdrawEndpoint`: FfiConverterOptionString.read(from: &buf),
            `swapInfo`: FfiConverterOptionTypeSwapInfo.read(from: &buf)
        )
    }

    public static func write(_ value: LnPaymentDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`paymentHash`, into: &buf)
        FfiConverterString.write(value.`label`, into: &buf)
        FfiConverterString.write(value.`destinationPubkey`, into: &buf)
        FfiConverterString.write(value.`paymentPreimage`, into: &buf)
        FfiConverterBool.write(value.`keysend`, into: &buf)
        FfiConverterString.write(value.`bolt11`, into: &buf)
        FfiConverterOptionTypeSuccessActionProcessed.write(value.`lnurlSuccessAction`, into: &buf)
        FfiConverterOptionString.write(value.`lnurlMetadata`, into: &buf)
        FfiConverterOptionString.write(value.`lnAddress`, into: &buf)
        FfiConverterOptionString.write(value.`lnurlWithdrawEndpoint`, into: &buf)
        FfiConverterOptionTypeSwapInfo.write(value.`swapInfo`, into: &buf)
    }
}


public func FfiConverterTypeLnPaymentDetails_lift(_ buf: RustBuffer) throws -> LnPaymentDetails {
    return try FfiConverterTypeLnPaymentDetails.lift(buf)
}

public func FfiConverterTypeLnPaymentDetails_lower(_ value: LnPaymentDetails) -> RustBuffer {
    return FfiConverterTypeLnPaymentDetails.lower(value)
}


public struct LnUrlAuthRequestData {
    public var `k1`: String
    public var `domain`: String
    public var `url`: String
    public var `action`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`k1`: String, `domain`: String, `url`: String, `action`: String? = nil) {
        self.`k1` = `k1`
        self.`domain` = `domain`
        self.`url` = `url`
        self.`action` = `action`
    }
}


extension LnUrlAuthRequestData: Equatable, Hashable {
    public static func ==(lhs: LnUrlAuthRequestData, rhs: LnUrlAuthRequestData) -> Bool {
        if lhs.`k1` != rhs.`k1` {
            return false
        }
        if lhs.`domain` != rhs.`domain` {
            return false
        }
        if lhs.`url` != rhs.`url` {
            return false
        }
        if lhs.`action` != rhs.`action` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`k1`)
        hasher.combine(`domain`)
        hasher.combine(`url`)
        hasher.combine(`action`)
    }
}


public struct FfiConverterTypeLnUrlAuthRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlAuthRequestData {
        return try LnUrlAuthRequestData(
            `k1`: FfiConverterString.read(from: &buf),
            `domain`: FfiConverterString.read(from: &buf),
            `url`: FfiConverterString.read(from: &buf),
            `action`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlAuthRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`k1`, into: &buf)
        FfiConverterString.write(value.`domain`, into: &buf)
        FfiConverterString.write(value.`url`, into: &buf)
        FfiConverterOptionString.write(value.`action`, into: &buf)
    }
}


public func FfiConverterTypeLnUrlAuthRequestData_lift(_ buf: RustBuffer) throws -> LnUrlAuthRequestData {
    return try FfiConverterTypeLnUrlAuthRequestData.lift(buf)
}

public func FfiConverterTypeLnUrlAuthRequestData_lower(_ value: LnUrlAuthRequestData) -> RustBuffer {
    return FfiConverterTypeLnUrlAuthRequestData.lower(value)
}


public struct LnUrlErrorData {
    public var `reason`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`reason`: String) {
        self.`reason` = `reason`
    }
}


extension LnUrlErrorData: Equatable, Hashable {
    public static func ==(lhs: LnUrlErrorData, rhs: LnUrlErrorData) -> Bool {
        if lhs.`reason` != rhs.`reason` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`reason`)
    }
}


public struct FfiConverterTypeLnUrlErrorData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlErrorData {
        return try LnUrlErrorData(
            `reason`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlErrorData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`reason`, into: &buf)
    }
}


public func FfiConverterTypeLnUrlErrorData_lift(_ buf: RustBuffer) throws -> LnUrlErrorData {
    return try FfiConverterTypeLnUrlErrorData.lift(buf)
}

public func FfiConverterTypeLnUrlErrorData_lower(_ value: LnUrlErrorData) -> RustBuffer {
    return FfiConverterTypeLnUrlErrorData.lower(value)
}


public struct LnUrlPayErrorData {
    public var `paymentHash`: String
    public var `reason`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`paymentHash`: String, `reason`: String) {
        self.`paymentHash` = `paymentHash`
        self.`reason` = `reason`
    }
}


extension LnUrlPayErrorData: Equatable, Hashable {
    public static func ==(lhs: LnUrlPayErrorData, rhs: LnUrlPayErrorData) -> Bool {
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`reason` != rhs.`reason` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`paymentHash`)
        hasher.combine(`reason`)
    }
}


public struct FfiConverterTypeLnUrlPayErrorData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayErrorData {
        return try LnUrlPayErrorData(
            `paymentHash`: FfiConverterString.read(from: &buf),
            `reason`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPayErrorData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`paymentHash`, into: &buf)
        FfiConverterString.write(value.`reason`, into: &buf)
    }
}


public func FfiConverterTypeLnUrlPayErrorData_lift(_ buf: RustBuffer) throws -> LnUrlPayErrorData {
    return try FfiConverterTypeLnUrlPayErrorData.lift(buf)
}

public func FfiConverterTypeLnUrlPayErrorData_lower(_ value: LnUrlPayErrorData) -> RustBuffer {
    return FfiConverterTypeLnUrlPayErrorData.lower(value)
}


public struct LnUrlPayRequest {
    public var `data`: LnUrlPayRequestData
    public var `amountMsat`: UInt64
    public var `comment`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`data`: LnUrlPayRequestData, `amountMsat`: UInt64, `comment`: String? = nil) {
        self.`data` = `data`
        self.`amountMsat` = `amountMsat`
        self.`comment` = `comment`
    }
}


extension LnUrlPayRequest: Equatable, Hashable {
    public static func ==(lhs: LnUrlPayRequest, rhs: LnUrlPayRequest) -> Bool {
        if lhs.`data` != rhs.`data` {
            return false
        }
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        if lhs.`comment` != rhs.`comment` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`data`)
        hasher.combine(`amountMsat`)
        hasher.combine(`comment`)
    }
}


public struct FfiConverterTypeLnUrlPayRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayRequest {
        return try LnUrlPayRequest(
            `data`: FfiConverterTypeLnUrlPayRequestData.read(from: &buf),
            `amountMsat`: FfiConverterUInt64.read(from: &buf),
            `comment`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPayRequest, into buf: inout [UInt8]) {
        FfiConverterTypeLnUrlPayRequestData.write(value.`data`, into: &buf)
        FfiConverterUInt64.write(value.`amountMsat`, into: &buf)
        FfiConverterOptionString.write(value.`comment`, into: &buf)
    }
}


public func FfiConverterTypeLnUrlPayRequest_lift(_ buf: RustBuffer) throws -> LnUrlPayRequest {
    return try FfiConverterTypeLnUrlPayRequest.lift(buf)
}

public func FfiConverterTypeLnUrlPayRequest_lower(_ value: LnUrlPayRequest) -> RustBuffer {
    return FfiConverterTypeLnUrlPayRequest.lower(value)
}


public struct LnUrlPayRequestData {
    public var `callback`: String
    public var `minSendable`: UInt64
    public var `maxSendable`: UInt64
    public var `metadataStr`: String
    public var `commentAllowed`: UInt16
    public var `domain`: String
    public var `lnAddress`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`callback`: String, `minSendable`: UInt64, `maxSendable`: UInt64, `metadataStr`: String, `commentAllowed`: UInt16, `domain`: String, `lnAddress`: String?) {
        self.`callback` = `callback`
        self.`minSendable` = `minSendable`
        self.`maxSendable` = `maxSendable`
        self.`metadataStr` = `metadataStr`
        self.`commentAllowed` = `commentAllowed`
        self.`domain` = `domain`
        self.`lnAddress` = `lnAddress`
    }
}


extension LnUrlPayRequestData: Equatable, Hashable {
    public static func ==(lhs: LnUrlPayRequestData, rhs: LnUrlPayRequestData) -> Bool {
        if lhs.`callback` != rhs.`callback` {
            return false
        }
        if lhs.`minSendable` != rhs.`minSendable` {
            return false
        }
        if lhs.`maxSendable` != rhs.`maxSendable` {
            return false
        }
        if lhs.`metadataStr` != rhs.`metadataStr` {
            return false
        }
        if lhs.`commentAllowed` != rhs.`commentAllowed` {
            return false
        }
        if lhs.`domain` != rhs.`domain` {
            return false
        }
        if lhs.`lnAddress` != rhs.`lnAddress` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`callback`)
        hasher.combine(`minSendable`)
        hasher.combine(`maxSendable`)
        hasher.combine(`metadataStr`)
        hasher.combine(`commentAllowed`)
        hasher.combine(`domain`)
        hasher.combine(`lnAddress`)
    }
}


public struct FfiConverterTypeLnUrlPayRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayRequestData {
        return try LnUrlPayRequestData(
            `callback`: FfiConverterString.read(from: &buf),
            `minSendable`: FfiConverterUInt64.read(from: &buf),
            `maxSendable`: FfiConverterUInt64.read(from: &buf),
            `metadataStr`: FfiConverterString.read(from: &buf),
            `commentAllowed`: FfiConverterUInt16.read(from: &buf),
            `domain`: FfiConverterString.read(from: &buf),
            `lnAddress`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPayRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`callback`, into: &buf)
        FfiConverterUInt64.write(value.`minSendable`, into: &buf)
        FfiConverterUInt64.write(value.`maxSendable`, into: &buf)
        FfiConverterString.write(value.`metadataStr`, into: &buf)
        FfiConverterUInt16.write(value.`commentAllowed`, into: &buf)
        FfiConverterString.write(value.`domain`, into: &buf)
        FfiConverterOptionString.write(value.`lnAddress`, into: &buf)
    }
}


public func FfiConverterTypeLnUrlPayRequestData_lift(_ buf: RustBuffer) throws -> LnUrlPayRequestData {
    return try FfiConverterTypeLnUrlPayRequestData.lift(buf)
}

public func FfiConverterTypeLnUrlPayRequestData_lower(_ value: LnUrlPayRequestData) -> RustBuffer {
    return FfiConverterTypeLnUrlPayRequestData.lower(value)
}


public struct LnUrlPaySuccessData {
    public var `successAction`: SuccessActionProcessed?
    public var `paymentHash`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`successAction`: SuccessActionProcessed?, `paymentHash`: String) {
        self.`successAction` = `successAction`
        self.`paymentHash` = `paymentHash`
    }
}


extension LnUrlPaySuccessData: Equatable, Hashable {
    public static func ==(lhs: LnUrlPaySuccessData, rhs: LnUrlPaySuccessData) -> Bool {
        if lhs.`successAction` != rhs.`successAction` {
            return false
        }
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`successAction`)
        hasher.combine(`paymentHash`)
    }
}


public struct FfiConverterTypeLnUrlPaySuccessData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPaySuccessData {
        return try LnUrlPaySuccessData(
            `successAction`: FfiConverterOptionTypeSuccessActionProcessed.read(from: &buf),
            `paymentHash`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlPaySuccessData, into buf: inout [UInt8]) {
        FfiConverterOptionTypeSuccessActionProcessed.write(value.`successAction`, into: &buf)
        FfiConverterString.write(value.`paymentHash`, into: &buf)
    }
}


public func FfiConverterTypeLnUrlPaySuccessData_lift(_ buf: RustBuffer) throws -> LnUrlPaySuccessData {
    return try FfiConverterTypeLnUrlPaySuccessData.lift(buf)
}

public func FfiConverterTypeLnUrlPaySuccessData_lower(_ value: LnUrlPaySuccessData) -> RustBuffer {
    return FfiConverterTypeLnUrlPaySuccessData.lower(value)
}


public struct LnUrlWithdrawRequest {
    public var `data`: LnUrlWithdrawRequestData
    public var `amountMsat`: UInt64
    public var `description`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`data`: LnUrlWithdrawRequestData, `amountMsat`: UInt64, `description`: String? = nil) {
        self.`data` = `data`
        self.`amountMsat` = `amountMsat`
        self.`description` = `description`
    }
}


extension LnUrlWithdrawRequest: Equatable, Hashable {
    public static func ==(lhs: LnUrlWithdrawRequest, rhs: LnUrlWithdrawRequest) -> Bool {
        if lhs.`data` != rhs.`data` {
            return false
        }
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`data`)
        hasher.combine(`amountMsat`)
        hasher.combine(`description`)
    }
}


public struct FfiConverterTypeLnUrlWithdrawRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawRequest {
        return try LnUrlWithdrawRequest(
            `data`: FfiConverterTypeLnUrlWithdrawRequestData.read(from: &buf),
            `amountMsat`: FfiConverterUInt64.read(from: &buf),
            `description`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlWithdrawRequest, into buf: inout [UInt8]) {
        FfiConverterTypeLnUrlWithdrawRequestData.write(value.`data`, into: &buf)
        FfiConverterUInt64.write(value.`amountMsat`, into: &buf)
        FfiConverterOptionString.write(value.`description`, into: &buf)
    }
}


public func FfiConverterTypeLnUrlWithdrawRequest_lift(_ buf: RustBuffer) throws -> LnUrlWithdrawRequest {
    return try FfiConverterTypeLnUrlWithdrawRequest.lift(buf)
}

public func FfiConverterTypeLnUrlWithdrawRequest_lower(_ value: LnUrlWithdrawRequest) -> RustBuffer {
    return FfiConverterTypeLnUrlWithdrawRequest.lower(value)
}


public struct LnUrlWithdrawRequestData {
    public var `callback`: String
    public var `k1`: String
    public var `defaultDescription`: String
    public var `minWithdrawable`: UInt64
    public var `maxWithdrawable`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`callback`: String, `k1`: String, `defaultDescription`: String, `minWithdrawable`: UInt64, `maxWithdrawable`: UInt64) {
        self.`callback` = `callback`
        self.`k1` = `k1`
        self.`defaultDescription` = `defaultDescription`
        self.`minWithdrawable` = `minWithdrawable`
        self.`maxWithdrawable` = `maxWithdrawable`
    }
}


extension LnUrlWithdrawRequestData: Equatable, Hashable {
    public static func ==(lhs: LnUrlWithdrawRequestData, rhs: LnUrlWithdrawRequestData) -> Bool {
        if lhs.`callback` != rhs.`callback` {
            return false
        }
        if lhs.`k1` != rhs.`k1` {
            return false
        }
        if lhs.`defaultDescription` != rhs.`defaultDescription` {
            return false
        }
        if lhs.`minWithdrawable` != rhs.`minWithdrawable` {
            return false
        }
        if lhs.`maxWithdrawable` != rhs.`maxWithdrawable` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`callback`)
        hasher.combine(`k1`)
        hasher.combine(`defaultDescription`)
        hasher.combine(`minWithdrawable`)
        hasher.combine(`maxWithdrawable`)
    }
}


public struct FfiConverterTypeLnUrlWithdrawRequestData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawRequestData {
        return try LnUrlWithdrawRequestData(
            `callback`: FfiConverterString.read(from: &buf),
            `k1`: FfiConverterString.read(from: &buf),
            `defaultDescription`: FfiConverterString.read(from: &buf),
            `minWithdrawable`: FfiConverterUInt64.read(from: &buf),
            `maxWithdrawable`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlWithdrawRequestData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`callback`, into: &buf)
        FfiConverterString.write(value.`k1`, into: &buf)
        FfiConverterString.write(value.`defaultDescription`, into: &buf)
        FfiConverterUInt64.write(value.`minWithdrawable`, into: &buf)
        FfiConverterUInt64.write(value.`maxWithdrawable`, into: &buf)
    }
}


public func FfiConverterTypeLnUrlWithdrawRequestData_lift(_ buf: RustBuffer) throws -> LnUrlWithdrawRequestData {
    return try FfiConverterTypeLnUrlWithdrawRequestData.lift(buf)
}

public func FfiConverterTypeLnUrlWithdrawRequestData_lower(_ value: LnUrlWithdrawRequestData) -> RustBuffer {
    return FfiConverterTypeLnUrlWithdrawRequestData.lower(value)
}


public struct LnUrlWithdrawSuccessData {
    public var `invoice`: LnInvoice

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`invoice`: LnInvoice) {
        self.`invoice` = `invoice`
    }
}


extension LnUrlWithdrawSuccessData: Equatable, Hashable {
    public static func ==(lhs: LnUrlWithdrawSuccessData, rhs: LnUrlWithdrawSuccessData) -> Bool {
        if lhs.`invoice` != rhs.`invoice` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`invoice`)
    }
}


public struct FfiConverterTypeLnUrlWithdrawSuccessData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawSuccessData {
        return try LnUrlWithdrawSuccessData(
            `invoice`: FfiConverterTypeLnInvoice.read(from: &buf)
        )
    }

    public static func write(_ value: LnUrlWithdrawSuccessData, into buf: inout [UInt8]) {
        FfiConverterTypeLnInvoice.write(value.`invoice`, into: &buf)
    }
}


public func FfiConverterTypeLnUrlWithdrawSuccessData_lift(_ buf: RustBuffer) throws -> LnUrlWithdrawSuccessData {
    return try FfiConverterTypeLnUrlWithdrawSuccessData.lift(buf)
}

public func FfiConverterTypeLnUrlWithdrawSuccessData_lower(_ value: LnUrlWithdrawSuccessData) -> RustBuffer {
    return FfiConverterTypeLnUrlWithdrawSuccessData.lower(value)
}


public struct LocaleOverrides {
    public var `locale`: String
    public var `spacing`: UInt32?
    public var `symbol`: Symbol

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`locale`: String, `spacing`: UInt32?, `symbol`: Symbol) {
        self.`locale` = `locale`
        self.`spacing` = `spacing`
        self.`symbol` = `symbol`
    }
}


extension LocaleOverrides: Equatable, Hashable {
    public static func ==(lhs: LocaleOverrides, rhs: LocaleOverrides) -> Bool {
        if lhs.`locale` != rhs.`locale` {
            return false
        }
        if lhs.`spacing` != rhs.`spacing` {
            return false
        }
        if lhs.`symbol` != rhs.`symbol` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`locale`)
        hasher.combine(`spacing`)
        hasher.combine(`symbol`)
    }
}


public struct FfiConverterTypeLocaleOverrides: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocaleOverrides {
        return try LocaleOverrides(
            `locale`: FfiConverterString.read(from: &buf),
            `spacing`: FfiConverterOptionUInt32.read(from: &buf),
            `symbol`: FfiConverterTypeSymbol.read(from: &buf)
        )
    }

    public static func write(_ value: LocaleOverrides, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`locale`, into: &buf)
        FfiConverterOptionUInt32.write(value.`spacing`, into: &buf)
        FfiConverterTypeSymbol.write(value.`symbol`, into: &buf)
    }
}


public func FfiConverterTypeLocaleOverrides_lift(_ buf: RustBuffer) throws -> LocaleOverrides {
    return try FfiConverterTypeLocaleOverrides.lift(buf)
}

public func FfiConverterTypeLocaleOverrides_lower(_ value: LocaleOverrides) -> RustBuffer {
    return FfiConverterTypeLocaleOverrides.lower(value)
}


public struct LocalizedName {
    public var `locale`: String
    public var `name`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`locale`: String, `name`: String) {
        self.`locale` = `locale`
        self.`name` = `name`
    }
}


extension LocalizedName: Equatable, Hashable {
    public static func ==(lhs: LocalizedName, rhs: LocalizedName) -> Bool {
        if lhs.`locale` != rhs.`locale` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`locale`)
        hasher.combine(`name`)
    }
}


public struct FfiConverterTypeLocalizedName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalizedName {
        return try LocalizedName(
            `locale`: FfiConverterString.read(from: &buf),
            `name`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LocalizedName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`locale`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
    }
}


public func FfiConverterTypeLocalizedName_lift(_ buf: RustBuffer) throws -> LocalizedName {
    return try FfiConverterTypeLocalizedName.lift(buf)
}

public func FfiConverterTypeLocalizedName_lower(_ value: LocalizedName) -> RustBuffer {
    return FfiConverterTypeLocalizedName.lower(value)
}


public struct LogEntry {
    public var `line`: String
    public var `level`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`line`: String, `level`: String) {
        self.`line` = `line`
        self.`level` = `level`
    }
}


extension LogEntry: Equatable, Hashable {
    public static func ==(lhs: LogEntry, rhs: LogEntry) -> Bool {
        if lhs.`line` != rhs.`line` {
            return false
        }
        if lhs.`level` != rhs.`level` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`line`)
        hasher.combine(`level`)
    }
}


public struct FfiConverterTypeLogEntry: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogEntry {
        return try LogEntry(
            `line`: FfiConverterString.read(from: &buf),
            `level`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LogEntry, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`line`, into: &buf)
        FfiConverterString.write(value.`level`, into: &buf)
    }
}


public func FfiConverterTypeLogEntry_lift(_ buf: RustBuffer) throws -> LogEntry {
    return try FfiConverterTypeLogEntry.lift(buf)
}

public func FfiConverterTypeLogEntry_lower(_ value: LogEntry) -> RustBuffer {
    return FfiConverterTypeLogEntry.lower(value)
}


public struct LspInformation {
    public var `id`: String
    public var `name`: String
    public var `widgetUrl`: String
    public var `pubkey`: String
    public var `host`: String
    public var `channelCapacity`: Int64
    public var `targetConf`: Int32
    public var `baseFeeMsat`: Int64
    public var `feeRate`: Double
    public var `timeLockDelta`: UInt32
    public var `minHtlcMsat`: Int64
    public var `lspPubkey`: [UInt8]
    public var `openingFeeParamsList`: OpeningFeeParamsMenu

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `name`: String, `widgetUrl`: String, `pubkey`: String, `host`: String, `channelCapacity`: Int64, `targetConf`: Int32, `baseFeeMsat`: Int64, `feeRate`: Double, `timeLockDelta`: UInt32, `minHtlcMsat`: Int64, `lspPubkey`: [UInt8], `openingFeeParamsList`: OpeningFeeParamsMenu) {
        self.`id` = `id`
        self.`name` = `name`
        self.`widgetUrl` = `widgetUrl`
        self.`pubkey` = `pubkey`
        self.`host` = `host`
        self.`channelCapacity` = `channelCapacity`
        self.`targetConf` = `targetConf`
        self.`baseFeeMsat` = `baseFeeMsat`
        self.`feeRate` = `feeRate`
        self.`timeLockDelta` = `timeLockDelta`
        self.`minHtlcMsat` = `minHtlcMsat`
        self.`lspPubkey` = `lspPubkey`
        self.`openingFeeParamsList` = `openingFeeParamsList`
    }
}


extension LspInformation: Equatable, Hashable {
    public static func ==(lhs: LspInformation, rhs: LspInformation) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`widgetUrl` != rhs.`widgetUrl` {
            return false
        }
        if lhs.`pubkey` != rhs.`pubkey` {
            return false
        }
        if lhs.`host` != rhs.`host` {
            return false
        }
        if lhs.`channelCapacity` != rhs.`channelCapacity` {
            return false
        }
        if lhs.`targetConf` != rhs.`targetConf` {
            return false
        }
        if lhs.`baseFeeMsat` != rhs.`baseFeeMsat` {
            return false
        }
        if lhs.`feeRate` != rhs.`feeRate` {
            return false
        }
        if lhs.`timeLockDelta` != rhs.`timeLockDelta` {
            return false
        }
        if lhs.`minHtlcMsat` != rhs.`minHtlcMsat` {
            return false
        }
        if lhs.`lspPubkey` != rhs.`lspPubkey` {
            return false
        }
        if lhs.`openingFeeParamsList` != rhs.`openingFeeParamsList` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`name`)
        hasher.combine(`widgetUrl`)
        hasher.combine(`pubkey`)
        hasher.combine(`host`)
        hasher.combine(`channelCapacity`)
        hasher.combine(`targetConf`)
        hasher.combine(`baseFeeMsat`)
        hasher.combine(`feeRate`)
        hasher.combine(`timeLockDelta`)
        hasher.combine(`minHtlcMsat`)
        hasher.combine(`lspPubkey`)
        hasher.combine(`openingFeeParamsList`)
    }
}


public struct FfiConverterTypeLspInformation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LspInformation {
        return try LspInformation(
            `id`: FfiConverterString.read(from: &buf),
            `name`: FfiConverterString.read(from: &buf),
            `widgetUrl`: FfiConverterString.read(from: &buf),
            `pubkey`: FfiConverterString.read(from: &buf),
            `host`: FfiConverterString.read(from: &buf),
            `channelCapacity`: FfiConverterInt64.read(from: &buf),
            `targetConf`: FfiConverterInt32.read(from: &buf),
            `baseFeeMsat`: FfiConverterInt64.read(from: &buf),
            `feeRate`: FfiConverterDouble.read(from: &buf),
            `timeLockDelta`: FfiConverterUInt32.read(from: &buf),
            `minHtlcMsat`: FfiConverterInt64.read(from: &buf),
            `lspPubkey`: FfiConverterSequenceUInt8.read(from: &buf),
            `openingFeeParamsList`: FfiConverterTypeOpeningFeeParamsMenu.read(from: &buf)
        )
    }

    public static func write(_ value: LspInformation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`widgetUrl`, into: &buf)
        FfiConverterString.write(value.`pubkey`, into: &buf)
        FfiConverterString.write(value.`host`, into: &buf)
        FfiConverterInt64.write(value.`channelCapacity`, into: &buf)
        FfiConverterInt32.write(value.`targetConf`, into: &buf)
        FfiConverterInt64.write(value.`baseFeeMsat`, into: &buf)
        FfiConverterDouble.write(value.`feeRate`, into: &buf)
        FfiConverterUInt32.write(value.`timeLockDelta`, into: &buf)
        FfiConverterInt64.write(value.`minHtlcMsat`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`lspPubkey`, into: &buf)
        FfiConverterTypeOpeningFeeParamsMenu.write(value.`openingFeeParamsList`, into: &buf)
    }
}


public func FfiConverterTypeLspInformation_lift(_ buf: RustBuffer) throws -> LspInformation {
    return try FfiConverterTypeLspInformation.lift(buf)
}

public func FfiConverterTypeLspInformation_lower(_ value: LspInformation) -> RustBuffer {
    return FfiConverterTypeLspInformation.lower(value)
}


public struct MaxReverseSwapAmountResponse {
    public var `totalSat`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`totalSat`: UInt64) {
        self.`totalSat` = `totalSat`
    }
}


extension MaxReverseSwapAmountResponse: Equatable, Hashable {
    public static func ==(lhs: MaxReverseSwapAmountResponse, rhs: MaxReverseSwapAmountResponse) -> Bool {
        if lhs.`totalSat` != rhs.`totalSat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`totalSat`)
    }
}


public struct FfiConverterTypeMaxReverseSwapAmountResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MaxReverseSwapAmountResponse {
        return try MaxReverseSwapAmountResponse(
            `totalSat`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: MaxReverseSwapAmountResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`totalSat`, into: &buf)
    }
}


public func FfiConverterTypeMaxReverseSwapAmountResponse_lift(_ buf: RustBuffer) throws -> MaxReverseSwapAmountResponse {
    return try FfiConverterTypeMaxReverseSwapAmountResponse.lift(buf)
}

public func FfiConverterTypeMaxReverseSwapAmountResponse_lower(_ value: MaxReverseSwapAmountResponse) -> RustBuffer {
    return FfiConverterTypeMaxReverseSwapAmountResponse.lower(value)
}


public struct MessageSuccessActionData {
    public var `message`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`message`: String) {
        self.`message` = `message`
    }
}


extension MessageSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: MessageSuccessActionData, rhs: MessageSuccessActionData) -> Bool {
        if lhs.`message` != rhs.`message` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`message`)
    }
}


public struct FfiConverterTypeMessageSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageSuccessActionData {
        return try MessageSuccessActionData(
            `message`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MessageSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`message`, into: &buf)
    }
}


public func FfiConverterTypeMessageSuccessActionData_lift(_ buf: RustBuffer) throws -> MessageSuccessActionData {
    return try FfiConverterTypeMessageSuccessActionData.lift(buf)
}

public func FfiConverterTypeMessageSuccessActionData_lower(_ value: MessageSuccessActionData) -> RustBuffer {
    return FfiConverterTypeMessageSuccessActionData.lower(value)
}


public struct MetadataItem {
    public var `key`: String
    public var `value`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`key`: String, `value`: String) {
        self.`key` = `key`
        self.`value` = `value`
    }
}


extension MetadataItem: Equatable, Hashable {
    public static func ==(lhs: MetadataItem, rhs: MetadataItem) -> Bool {
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`key`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeMetadataItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetadataItem {
        return try MetadataItem(
            `key`: FfiConverterString.read(from: &buf),
            `value`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MetadataItem, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterString.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeMetadataItem_lift(_ buf: RustBuffer) throws -> MetadataItem {
    return try FfiConverterTypeMetadataItem.lift(buf)
}

public func FfiConverterTypeMetadataItem_lower(_ value: MetadataItem) -> RustBuffer {
    return FfiConverterTypeMetadataItem.lower(value)
}


public struct NodeState {
    public var `id`: String
    public var `blockHeight`: UInt32
    public var `channelsBalanceMsat`: UInt64
    public var `onchainBalanceMsat`: UInt64
    public var `utxos`: [UnspentTransactionOutput]
    public var `maxPayableMsat`: UInt64
    public var `maxReceivableMsat`: UInt64
    public var `maxSinglePaymentAmountMsat`: UInt64
    public var `maxChanReserveMsats`: UInt64
    public var `connectedPeers`: [String]
    public var `inboundLiquidityMsats`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `blockHeight`: UInt32, `channelsBalanceMsat`: UInt64, `onchainBalanceMsat`: UInt64, `utxos`: [UnspentTransactionOutput], `maxPayableMsat`: UInt64, `maxReceivableMsat`: UInt64, `maxSinglePaymentAmountMsat`: UInt64, `maxChanReserveMsats`: UInt64, `connectedPeers`: [String], `inboundLiquidityMsats`: UInt64) {
        self.`id` = `id`
        self.`blockHeight` = `blockHeight`
        self.`channelsBalanceMsat` = `channelsBalanceMsat`
        self.`onchainBalanceMsat` = `onchainBalanceMsat`
        self.`utxos` = `utxos`
        self.`maxPayableMsat` = `maxPayableMsat`
        self.`maxReceivableMsat` = `maxReceivableMsat`
        self.`maxSinglePaymentAmountMsat` = `maxSinglePaymentAmountMsat`
        self.`maxChanReserveMsats` = `maxChanReserveMsats`
        self.`connectedPeers` = `connectedPeers`
        self.`inboundLiquidityMsats` = `inboundLiquidityMsats`
    }
}


extension NodeState: Equatable, Hashable {
    public static func ==(lhs: NodeState, rhs: NodeState) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`blockHeight` != rhs.`blockHeight` {
            return false
        }
        if lhs.`channelsBalanceMsat` != rhs.`channelsBalanceMsat` {
            return false
        }
        if lhs.`onchainBalanceMsat` != rhs.`onchainBalanceMsat` {
            return false
        }
        if lhs.`utxos` != rhs.`utxos` {
            return false
        }
        if lhs.`maxPayableMsat` != rhs.`maxPayableMsat` {
            return false
        }
        if lhs.`maxReceivableMsat` != rhs.`maxReceivableMsat` {
            return false
        }
        if lhs.`maxSinglePaymentAmountMsat` != rhs.`maxSinglePaymentAmountMsat` {
            return false
        }
        if lhs.`maxChanReserveMsats` != rhs.`maxChanReserveMsats` {
            return false
        }
        if lhs.`connectedPeers` != rhs.`connectedPeers` {
            return false
        }
        if lhs.`inboundLiquidityMsats` != rhs.`inboundLiquidityMsats` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`blockHeight`)
        hasher.combine(`channelsBalanceMsat`)
        hasher.combine(`onchainBalanceMsat`)
        hasher.combine(`utxos`)
        hasher.combine(`maxPayableMsat`)
        hasher.combine(`maxReceivableMsat`)
        hasher.combine(`maxSinglePaymentAmountMsat`)
        hasher.combine(`maxChanReserveMsats`)
        hasher.combine(`connectedPeers`)
        hasher.combine(`inboundLiquidityMsats`)
    }
}


public struct FfiConverterTypeNodeState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeState {
        return try NodeState(
            `id`: FfiConverterString.read(from: &buf),
            `blockHeight`: FfiConverterUInt32.read(from: &buf),
            `channelsBalanceMsat`: FfiConverterUInt64.read(from: &buf),
            `onchainBalanceMsat`: FfiConverterUInt64.read(from: &buf),
            `utxos`: FfiConverterSequenceTypeUnspentTransactionOutput.read(from: &buf),
            `maxPayableMsat`: FfiConverterUInt64.read(from: &buf),
            `maxReceivableMsat`: FfiConverterUInt64.read(from: &buf),
            `maxSinglePaymentAmountMsat`: FfiConverterUInt64.read(from: &buf),
            `maxChanReserveMsats`: FfiConverterUInt64.read(from: &buf),
            `connectedPeers`: FfiConverterSequenceString.read(from: &buf),
            `inboundLiquidityMsats`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: NodeState, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterUInt32.write(value.`blockHeight`, into: &buf)
        FfiConverterUInt64.write(value.`channelsBalanceMsat`, into: &buf)
        FfiConverterUInt64.write(value.`onchainBalanceMsat`, into: &buf)
        FfiConverterSequenceTypeUnspentTransactionOutput.write(value.`utxos`, into: &buf)
        FfiConverterUInt64.write(value.`maxPayableMsat`, into: &buf)
        FfiConverterUInt64.write(value.`maxReceivableMsat`, into: &buf)
        FfiConverterUInt64.write(value.`maxSinglePaymentAmountMsat`, into: &buf)
        FfiConverterUInt64.write(value.`maxChanReserveMsats`, into: &buf)
        FfiConverterSequenceString.write(value.`connectedPeers`, into: &buf)
        FfiConverterUInt64.write(value.`inboundLiquidityMsats`, into: &buf)
    }
}


public func FfiConverterTypeNodeState_lift(_ buf: RustBuffer) throws -> NodeState {
    return try FfiConverterTypeNodeState.lift(buf)
}

public func FfiConverterTypeNodeState_lower(_ value: NodeState) -> RustBuffer {
    return FfiConverterTypeNodeState.lower(value)
}


public struct OpenChannelFeeRequest {
    public var `amountMsat`: UInt64
    public var `expiry`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amountMsat`: UInt64, `expiry`: UInt32? = nil) {
        self.`amountMsat` = `amountMsat`
        self.`expiry` = `expiry`
    }
}


extension OpenChannelFeeRequest: Equatable, Hashable {
    public static func ==(lhs: OpenChannelFeeRequest, rhs: OpenChannelFeeRequest) -> Bool {
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        if lhs.`expiry` != rhs.`expiry` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`amountMsat`)
        hasher.combine(`expiry`)
    }
}


public struct FfiConverterTypeOpenChannelFeeRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpenChannelFeeRequest {
        return try OpenChannelFeeRequest(
            `amountMsat`: FfiConverterUInt64.read(from: &buf),
            `expiry`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: OpenChannelFeeRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`amountMsat`, into: &buf)
        FfiConverterOptionUInt32.write(value.`expiry`, into: &buf)
    }
}


public func FfiConverterTypeOpenChannelFeeRequest_lift(_ buf: RustBuffer) throws -> OpenChannelFeeRequest {
    return try FfiConverterTypeOpenChannelFeeRequest.lift(buf)
}

public func FfiConverterTypeOpenChannelFeeRequest_lower(_ value: OpenChannelFeeRequest) -> RustBuffer {
    return FfiConverterTypeOpenChannelFeeRequest.lower(value)
}


public struct OpenChannelFeeResponse {
    public var `feeMsat`: UInt64
    public var `usedFeeParams`: OpeningFeeParams?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`feeMsat`: UInt64, `usedFeeParams`: OpeningFeeParams?) {
        self.`feeMsat` = `feeMsat`
        self.`usedFeeParams` = `usedFeeParams`
    }
}


extension OpenChannelFeeResponse: Equatable, Hashable {
    public static func ==(lhs: OpenChannelFeeResponse, rhs: OpenChannelFeeResponse) -> Bool {
        if lhs.`feeMsat` != rhs.`feeMsat` {
            return false
        }
        if lhs.`usedFeeParams` != rhs.`usedFeeParams` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`feeMsat`)
        hasher.combine(`usedFeeParams`)
    }
}


public struct FfiConverterTypeOpenChannelFeeResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpenChannelFeeResponse {
        return try OpenChannelFeeResponse(
            `feeMsat`: FfiConverterUInt64.read(from: &buf),
            `usedFeeParams`: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf)
        )
    }

    public static func write(_ value: OpenChannelFeeResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`feeMsat`, into: &buf)
        FfiConverterOptionTypeOpeningFeeParams.write(value.`usedFeeParams`, into: &buf)
    }
}


public func FfiConverterTypeOpenChannelFeeResponse_lift(_ buf: RustBuffer) throws -> OpenChannelFeeResponse {
    return try FfiConverterTypeOpenChannelFeeResponse.lift(buf)
}

public func FfiConverterTypeOpenChannelFeeResponse_lower(_ value: OpenChannelFeeResponse) -> RustBuffer {
    return FfiConverterTypeOpenChannelFeeResponse.lower(value)
}


public struct OpeningFeeParams {
    public var `minMsat`: UInt64
    public var `proportional`: UInt32
    public var `validUntil`: String
    public var `maxIdleTime`: UInt32
    public var `maxClientToSelfDelay`: UInt32
    public var `promise`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`minMsat`: UInt64, `proportional`: UInt32, `validUntil`: String, `maxIdleTime`: UInt32, `maxClientToSelfDelay`: UInt32, `promise`: String) {
        self.`minMsat` = `minMsat`
        self.`proportional` = `proportional`
        self.`validUntil` = `validUntil`
        self.`maxIdleTime` = `maxIdleTime`
        self.`maxClientToSelfDelay` = `maxClientToSelfDelay`
        self.`promise` = `promise`
    }
}


extension OpeningFeeParams: Equatable, Hashable {
    public static func ==(lhs: OpeningFeeParams, rhs: OpeningFeeParams) -> Bool {
        if lhs.`minMsat` != rhs.`minMsat` {
            return false
        }
        if lhs.`proportional` != rhs.`proportional` {
            return false
        }
        if lhs.`validUntil` != rhs.`validUntil` {
            return false
        }
        if lhs.`maxIdleTime` != rhs.`maxIdleTime` {
            return false
        }
        if lhs.`maxClientToSelfDelay` != rhs.`maxClientToSelfDelay` {
            return false
        }
        if lhs.`promise` != rhs.`promise` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`minMsat`)
        hasher.combine(`proportional`)
        hasher.combine(`validUntil`)
        hasher.combine(`maxIdleTime`)
        hasher.combine(`maxClientToSelfDelay`)
        hasher.combine(`promise`)
    }
}


public struct FfiConverterTypeOpeningFeeParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpeningFeeParams {
        return try OpeningFeeParams(
            `minMsat`: FfiConverterUInt64.read(from: &buf),
            `proportional`: FfiConverterUInt32.read(from: &buf),
            `validUntil`: FfiConverterString.read(from: &buf),
            `maxIdleTime`: FfiConverterUInt32.read(from: &buf),
            `maxClientToSelfDelay`: FfiConverterUInt32.read(from: &buf),
            `promise`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OpeningFeeParams, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`minMsat`, into: &buf)
        FfiConverterUInt32.write(value.`proportional`, into: &buf)
        FfiConverterString.write(value.`validUntil`, into: &buf)
        FfiConverterUInt32.write(value.`maxIdleTime`, into: &buf)
        FfiConverterUInt32.write(value.`maxClientToSelfDelay`, into: &buf)
        FfiConverterString.write(value.`promise`, into: &buf)
    }
}


public func FfiConverterTypeOpeningFeeParams_lift(_ buf: RustBuffer) throws -> OpeningFeeParams {
    return try FfiConverterTypeOpeningFeeParams.lift(buf)
}

public func FfiConverterTypeOpeningFeeParams_lower(_ value: OpeningFeeParams) -> RustBuffer {
    return FfiConverterTypeOpeningFeeParams.lower(value)
}


public struct OpeningFeeParamsMenu {
    public var `values`: [OpeningFeeParams]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`values`: [OpeningFeeParams]) {
        self.`values` = `values`
    }
}


extension OpeningFeeParamsMenu: Equatable, Hashable {
    public static func ==(lhs: OpeningFeeParamsMenu, rhs: OpeningFeeParamsMenu) -> Bool {
        if lhs.`values` != rhs.`values` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`values`)
    }
}


public struct FfiConverterTypeOpeningFeeParamsMenu: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OpeningFeeParamsMenu {
        return try OpeningFeeParamsMenu(
            `values`: FfiConverterSequenceTypeOpeningFeeParams.read(from: &buf)
        )
    }

    public static func write(_ value: OpeningFeeParamsMenu, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeOpeningFeeParams.write(value.`values`, into: &buf)
    }
}


public func FfiConverterTypeOpeningFeeParamsMenu_lift(_ buf: RustBuffer) throws -> OpeningFeeParamsMenu {
    return try FfiConverterTypeOpeningFeeParamsMenu.lift(buf)
}

public func FfiConverterTypeOpeningFeeParamsMenu_lower(_ value: OpeningFeeParamsMenu) -> RustBuffer {
    return FfiConverterTypeOpeningFeeParamsMenu.lower(value)
}


public struct Payment {
    public var `id`: String
    public var `paymentType`: PaymentType
    public var `paymentTime`: Int64
    public var `amountMsat`: UInt64
    public var `feeMsat`: UInt64
    public var `status`: PaymentStatus
    public var `description`: String?
    public var `details`: PaymentDetails

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `paymentType`: PaymentType, `paymentTime`: Int64, `amountMsat`: UInt64, `feeMsat`: UInt64, `status`: PaymentStatus, `description`: String?, `details`: PaymentDetails) {
        self.`id` = `id`
        self.`paymentType` = `paymentType`
        self.`paymentTime` = `paymentTime`
        self.`amountMsat` = `amountMsat`
        self.`feeMsat` = `feeMsat`
        self.`status` = `status`
        self.`description` = `description`
        self.`details` = `details`
    }
}


extension Payment: Equatable, Hashable {
    public static func ==(lhs: Payment, rhs: Payment) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`paymentType` != rhs.`paymentType` {
            return false
        }
        if lhs.`paymentTime` != rhs.`paymentTime` {
            return false
        }
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        if lhs.`feeMsat` != rhs.`feeMsat` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`details` != rhs.`details` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`paymentType`)
        hasher.combine(`paymentTime`)
        hasher.combine(`amountMsat`)
        hasher.combine(`feeMsat`)
        hasher.combine(`status`)
        hasher.combine(`description`)
        hasher.combine(`details`)
    }
}


public struct FfiConverterTypePayment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Payment {
        return try Payment(
            `id`: FfiConverterString.read(from: &buf),
            `paymentType`: FfiConverterTypePaymentType.read(from: &buf),
            `paymentTime`: FfiConverterInt64.read(from: &buf),
            `amountMsat`: FfiConverterUInt64.read(from: &buf),
            `feeMsat`: FfiConverterUInt64.read(from: &buf),
            `status`: FfiConverterTypePaymentStatus.read(from: &buf),
            `description`: FfiConverterOptionString.read(from: &buf),
            `details`: FfiConverterTypePaymentDetails.read(from: &buf)
        )
    }

    public static func write(_ value: Payment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterTypePaymentType.write(value.`paymentType`, into: &buf)
        FfiConverterInt64.write(value.`paymentTime`, into: &buf)
        FfiConverterUInt64.write(value.`amountMsat`, into: &buf)
        FfiConverterUInt64.write(value.`feeMsat`, into: &buf)
        FfiConverterTypePaymentStatus.write(value.`status`, into: &buf)
        FfiConverterOptionString.write(value.`description`, into: &buf)
        FfiConverterTypePaymentDetails.write(value.`details`, into: &buf)
    }
}


public func FfiConverterTypePayment_lift(_ buf: RustBuffer) throws -> Payment {
    return try FfiConverterTypePayment.lift(buf)
}

public func FfiConverterTypePayment_lower(_ value: Payment) -> RustBuffer {
    return FfiConverterTypePayment.lower(value)
}


public struct PaymentFailedData {
    public var `error`: String
    public var `nodeId`: String
    public var `invoice`: LnInvoice?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`error`: String, `nodeId`: String, `invoice`: LnInvoice?) {
        self.`error` = `error`
        self.`nodeId` = `nodeId`
        self.`invoice` = `invoice`
    }
}


extension PaymentFailedData: Equatable, Hashable {
    public static func ==(lhs: PaymentFailedData, rhs: PaymentFailedData) -> Bool {
        if lhs.`error` != rhs.`error` {
            return false
        }
        if lhs.`nodeId` != rhs.`nodeId` {
            return false
        }
        if lhs.`invoice` != rhs.`invoice` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`error`)
        hasher.combine(`nodeId`)
        hasher.combine(`invoice`)
    }
}


public struct FfiConverterTypePaymentFailedData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentFailedData {
        return try PaymentFailedData(
            `error`: FfiConverterString.read(from: &buf),
            `nodeId`: FfiConverterString.read(from: &buf),
            `invoice`: FfiConverterOptionTypeLnInvoice.read(from: &buf)
        )
    }

    public static func write(_ value: PaymentFailedData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`error`, into: &buf)
        FfiConverterString.write(value.`nodeId`, into: &buf)
        FfiConverterOptionTypeLnInvoice.write(value.`invoice`, into: &buf)
    }
}


public func FfiConverterTypePaymentFailedData_lift(_ buf: RustBuffer) throws -> PaymentFailedData {
    return try FfiConverterTypePaymentFailedData.lift(buf)
}

public func FfiConverterTypePaymentFailedData_lower(_ value: PaymentFailedData) -> RustBuffer {
    return FfiConverterTypePaymentFailedData.lower(value)
}


public struct PrepareRefundRequest {
    public var `swapAddress`: String
    public var `toAddress`: String
    public var `satPerVbyte`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`swapAddress`: String, `toAddress`: String, `satPerVbyte`: UInt32) {
        self.`swapAddress` = `swapAddress`
        self.`toAddress` = `toAddress`
        self.`satPerVbyte` = `satPerVbyte`
    }
}


extension PrepareRefundRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareRefundRequest, rhs: PrepareRefundRequest) -> Bool {
        if lhs.`swapAddress` != rhs.`swapAddress` {
            return false
        }
        if lhs.`toAddress` != rhs.`toAddress` {
            return false
        }
        if lhs.`satPerVbyte` != rhs.`satPerVbyte` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`swapAddress`)
        hasher.combine(`toAddress`)
        hasher.combine(`satPerVbyte`)
    }
}


public struct FfiConverterTypePrepareRefundRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareRefundRequest {
        return try PrepareRefundRequest(
            `swapAddress`: FfiConverterString.read(from: &buf),
            `toAddress`: FfiConverterString.read(from: &buf),
            `satPerVbyte`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareRefundRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`swapAddress`, into: &buf)
        FfiConverterString.write(value.`toAddress`, into: &buf)
        FfiConverterUInt32.write(value.`satPerVbyte`, into: &buf)
    }
}


public func FfiConverterTypePrepareRefundRequest_lift(_ buf: RustBuffer) throws -> PrepareRefundRequest {
    return try FfiConverterTypePrepareRefundRequest.lift(buf)
}

public func FfiConverterTypePrepareRefundRequest_lower(_ value: PrepareRefundRequest) -> RustBuffer {
    return FfiConverterTypePrepareRefundRequest.lower(value)
}


public struct PrepareRefundResponse {
    public var `refundTxWeight`: UInt32
    public var `refundTxFeeSat`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`refundTxWeight`: UInt32, `refundTxFeeSat`: UInt64) {
        self.`refundTxWeight` = `refundTxWeight`
        self.`refundTxFeeSat` = `refundTxFeeSat`
    }
}


extension PrepareRefundResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareRefundResponse, rhs: PrepareRefundResponse) -> Bool {
        if lhs.`refundTxWeight` != rhs.`refundTxWeight` {
            return false
        }
        if lhs.`refundTxFeeSat` != rhs.`refundTxFeeSat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`refundTxWeight`)
        hasher.combine(`refundTxFeeSat`)
    }
}


public struct FfiConverterTypePrepareRefundResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareRefundResponse {
        return try PrepareRefundResponse(
            `refundTxWeight`: FfiConverterUInt32.read(from: &buf),
            `refundTxFeeSat`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareRefundResponse, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`refundTxWeight`, into: &buf)
        FfiConverterUInt64.write(value.`refundTxFeeSat`, into: &buf)
    }
}


public func FfiConverterTypePrepareRefundResponse_lift(_ buf: RustBuffer) throws -> PrepareRefundResponse {
    return try FfiConverterTypePrepareRefundResponse.lift(buf)
}

public func FfiConverterTypePrepareRefundResponse_lower(_ value: PrepareRefundResponse) -> RustBuffer {
    return FfiConverterTypePrepareRefundResponse.lower(value)
}


public struct PrepareSweepRequest {
    public var `toAddress`: String
    public var `satPerVbyte`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`toAddress`: String, `satPerVbyte`: UInt64) {
        self.`toAddress` = `toAddress`
        self.`satPerVbyte` = `satPerVbyte`
    }
}


extension PrepareSweepRequest: Equatable, Hashable {
    public static func ==(lhs: PrepareSweepRequest, rhs: PrepareSweepRequest) -> Bool {
        if lhs.`toAddress` != rhs.`toAddress` {
            return false
        }
        if lhs.`satPerVbyte` != rhs.`satPerVbyte` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`toAddress`)
        hasher.combine(`satPerVbyte`)
    }
}


public struct FfiConverterTypePrepareSweepRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSweepRequest {
        return try PrepareSweepRequest(
            `toAddress`: FfiConverterString.read(from: &buf),
            `satPerVbyte`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSweepRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`toAddress`, into: &buf)
        FfiConverterUInt64.write(value.`satPerVbyte`, into: &buf)
    }
}


public func FfiConverterTypePrepareSweepRequest_lift(_ buf: RustBuffer) throws -> PrepareSweepRequest {
    return try FfiConverterTypePrepareSweepRequest.lift(buf)
}

public func FfiConverterTypePrepareSweepRequest_lower(_ value: PrepareSweepRequest) -> RustBuffer {
    return FfiConverterTypePrepareSweepRequest.lower(value)
}


public struct PrepareSweepResponse {
    public var `sweepTxWeight`: UInt64
    public var `sweepTxFeeSat`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`sweepTxWeight`: UInt64, `sweepTxFeeSat`: UInt64) {
        self.`sweepTxWeight` = `sweepTxWeight`
        self.`sweepTxFeeSat` = `sweepTxFeeSat`
    }
}


extension PrepareSweepResponse: Equatable, Hashable {
    public static func ==(lhs: PrepareSweepResponse, rhs: PrepareSweepResponse) -> Bool {
        if lhs.`sweepTxWeight` != rhs.`sweepTxWeight` {
            return false
        }
        if lhs.`sweepTxFeeSat` != rhs.`sweepTxFeeSat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`sweepTxWeight`)
        hasher.combine(`sweepTxFeeSat`)
    }
}


public struct FfiConverterTypePrepareSweepResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrepareSweepResponse {
        return try PrepareSweepResponse(
            `sweepTxWeight`: FfiConverterUInt64.read(from: &buf),
            `sweepTxFeeSat`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PrepareSweepResponse, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`sweepTxWeight`, into: &buf)
        FfiConverterUInt64.write(value.`sweepTxFeeSat`, into: &buf)
    }
}


public func FfiConverterTypePrepareSweepResponse_lift(_ buf: RustBuffer) throws -> PrepareSweepResponse {
    return try FfiConverterTypePrepareSweepResponse.lift(buf)
}

public func FfiConverterTypePrepareSweepResponse_lower(_ value: PrepareSweepResponse) -> RustBuffer {
    return FfiConverterTypePrepareSweepResponse.lower(value)
}


public struct Rate {
    public var `coin`: String
    public var `value`: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`coin`: String, `value`: Double) {
        self.`coin` = `coin`
        self.`value` = `value`
    }
}


extension Rate: Equatable, Hashable {
    public static func ==(lhs: Rate, rhs: Rate) -> Bool {
        if lhs.`coin` != rhs.`coin` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`coin`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeRate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Rate {
        return try Rate(
            `coin`: FfiConverterString.read(from: &buf),
            `value`: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: Rate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`coin`, into: &buf)
        FfiConverterDouble.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeRate_lift(_ buf: RustBuffer) throws -> Rate {
    return try FfiConverterTypeRate.lift(buf)
}

public func FfiConverterTypeRate_lower(_ value: Rate) -> RustBuffer {
    return FfiConverterTypeRate.lower(value)
}


public struct ReceiveOnchainRequest {
    public var `openingFeeParams`: OpeningFeeParams?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`openingFeeParams`: OpeningFeeParams? = nil) {
        self.`openingFeeParams` = `openingFeeParams`
    }
}


extension ReceiveOnchainRequest: Equatable, Hashable {
    public static func ==(lhs: ReceiveOnchainRequest, rhs: ReceiveOnchainRequest) -> Bool {
        if lhs.`openingFeeParams` != rhs.`openingFeeParams` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`openingFeeParams`)
    }
}


public struct FfiConverterTypeReceiveOnchainRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiveOnchainRequest {
        return try ReceiveOnchainRequest(
            `openingFeeParams`: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf)
        )
    }

    public static func write(_ value: ReceiveOnchainRequest, into buf: inout [UInt8]) {
        FfiConverterOptionTypeOpeningFeeParams.write(value.`openingFeeParams`, into: &buf)
    }
}


public func FfiConverterTypeReceiveOnchainRequest_lift(_ buf: RustBuffer) throws -> ReceiveOnchainRequest {
    return try FfiConverterTypeReceiveOnchainRequest.lift(buf)
}

public func FfiConverterTypeReceiveOnchainRequest_lower(_ value: ReceiveOnchainRequest) -> RustBuffer {
    return FfiConverterTypeReceiveOnchainRequest.lower(value)
}


public struct ReceivePaymentRequest {
    public var `amountMsat`: UInt64
    public var `description`: String
    public var `preimage`: [UInt8]?
    public var `openingFeeParams`: OpeningFeeParams?
    public var `useDescriptionHash`: Bool?
    public var `expiry`: UInt32?
    public var `cltv`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amountMsat`: UInt64, `description`: String, `preimage`: [UInt8]? = nil, `openingFeeParams`: OpeningFeeParams? = nil, `useDescriptionHash`: Bool? = nil, `expiry`: UInt32? = nil, `cltv`: UInt32? = nil) {
        self.`amountMsat` = `amountMsat`
        self.`description` = `description`
        self.`preimage` = `preimage`
        self.`openingFeeParams` = `openingFeeParams`
        self.`useDescriptionHash` = `useDescriptionHash`
        self.`expiry` = `expiry`
        self.`cltv` = `cltv`
    }
}


extension ReceivePaymentRequest: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentRequest, rhs: ReceivePaymentRequest) -> Bool {
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`preimage` != rhs.`preimage` {
            return false
        }
        if lhs.`openingFeeParams` != rhs.`openingFeeParams` {
            return false
        }
        if lhs.`useDescriptionHash` != rhs.`useDescriptionHash` {
            return false
        }
        if lhs.`expiry` != rhs.`expiry` {
            return false
        }
        if lhs.`cltv` != rhs.`cltv` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`amountMsat`)
        hasher.combine(`description`)
        hasher.combine(`preimage`)
        hasher.combine(`openingFeeParams`)
        hasher.combine(`useDescriptionHash`)
        hasher.combine(`expiry`)
        hasher.combine(`cltv`)
    }
}


public struct FfiConverterTypeReceivePaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentRequest {
        return try ReceivePaymentRequest(
            `amountMsat`: FfiConverterUInt64.read(from: &buf),
            `description`: FfiConverterString.read(from: &buf),
            `preimage`: FfiConverterOptionSequenceUInt8.read(from: &buf),
            `openingFeeParams`: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf),
            `useDescriptionHash`: FfiConverterOptionBool.read(from: &buf),
            `expiry`: FfiConverterOptionUInt32.read(from: &buf),
            `cltv`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`amountMsat`, into: &buf)
        FfiConverterString.write(value.`description`, into: &buf)
        FfiConverterOptionSequenceUInt8.write(value.`preimage`, into: &buf)
        FfiConverterOptionTypeOpeningFeeParams.write(value.`openingFeeParams`, into: &buf)
        FfiConverterOptionBool.write(value.`useDescriptionHash`, into: &buf)
        FfiConverterOptionUInt32.write(value.`expiry`, into: &buf)
        FfiConverterOptionUInt32.write(value.`cltv`, into: &buf)
    }
}


public func FfiConverterTypeReceivePaymentRequest_lift(_ buf: RustBuffer) throws -> ReceivePaymentRequest {
    return try FfiConverterTypeReceivePaymentRequest.lift(buf)
}

public func FfiConverterTypeReceivePaymentRequest_lower(_ value: ReceivePaymentRequest) -> RustBuffer {
    return FfiConverterTypeReceivePaymentRequest.lower(value)
}


public struct ReceivePaymentResponse {
    public var `lnInvoice`: LnInvoice
    public var `openingFeeParams`: OpeningFeeParams?
    public var `openingFeeMsat`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`lnInvoice`: LnInvoice, `openingFeeParams`: OpeningFeeParams?, `openingFeeMsat`: UInt64?) {
        self.`lnInvoice` = `lnInvoice`
        self.`openingFeeParams` = `openingFeeParams`
        self.`openingFeeMsat` = `openingFeeMsat`
    }
}


extension ReceivePaymentResponse: Equatable, Hashable {
    public static func ==(lhs: ReceivePaymentResponse, rhs: ReceivePaymentResponse) -> Bool {
        if lhs.`lnInvoice` != rhs.`lnInvoice` {
            return false
        }
        if lhs.`openingFeeParams` != rhs.`openingFeeParams` {
            return false
        }
        if lhs.`openingFeeMsat` != rhs.`openingFeeMsat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`lnInvoice`)
        hasher.combine(`openingFeeParams`)
        hasher.combine(`openingFeeMsat`)
    }
}


public struct FfiConverterTypeReceivePaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentResponse {
        return try ReceivePaymentResponse(
            `lnInvoice`: FfiConverterTypeLnInvoice.read(from: &buf),
            `openingFeeParams`: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf),
            `openingFeeMsat`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ReceivePaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypeLnInvoice.write(value.`lnInvoice`, into: &buf)
        FfiConverterOptionTypeOpeningFeeParams.write(value.`openingFeeParams`, into: &buf)
        FfiConverterOptionUInt64.write(value.`openingFeeMsat`, into: &buf)
    }
}


public func FfiConverterTypeReceivePaymentResponse_lift(_ buf: RustBuffer) throws -> ReceivePaymentResponse {
    return try FfiConverterTypeReceivePaymentResponse.lift(buf)
}

public func FfiConverterTypeReceivePaymentResponse_lower(_ value: ReceivePaymentResponse) -> RustBuffer {
    return FfiConverterTypeReceivePaymentResponse.lower(value)
}


public struct RecommendedFees {
    public var `fastestFee`: UInt64
    public var `halfHourFee`: UInt64
    public var `hourFee`: UInt64
    public var `economyFee`: UInt64
    public var `minimumFee`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`fastestFee`: UInt64, `halfHourFee`: UInt64, `hourFee`: UInt64, `economyFee`: UInt64, `minimumFee`: UInt64) {
        self.`fastestFee` = `fastestFee`
        self.`halfHourFee` = `halfHourFee`
        self.`hourFee` = `hourFee`
        self.`economyFee` = `economyFee`
        self.`minimumFee` = `minimumFee`
    }
}


extension RecommendedFees: Equatable, Hashable {
    public static func ==(lhs: RecommendedFees, rhs: RecommendedFees) -> Bool {
        if lhs.`fastestFee` != rhs.`fastestFee` {
            return false
        }
        if lhs.`halfHourFee` != rhs.`halfHourFee` {
            return false
        }
        if lhs.`hourFee` != rhs.`hourFee` {
            return false
        }
        if lhs.`economyFee` != rhs.`economyFee` {
            return false
        }
        if lhs.`minimumFee` != rhs.`minimumFee` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`fastestFee`)
        hasher.combine(`halfHourFee`)
        hasher.combine(`hourFee`)
        hasher.combine(`economyFee`)
        hasher.combine(`minimumFee`)
    }
}


public struct FfiConverterTypeRecommendedFees: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecommendedFees {
        return try RecommendedFees(
            `fastestFee`: FfiConverterUInt64.read(from: &buf),
            `halfHourFee`: FfiConverterUInt64.read(from: &buf),
            `hourFee`: FfiConverterUInt64.read(from: &buf),
            `economyFee`: FfiConverterUInt64.read(from: &buf),
            `minimumFee`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RecommendedFees, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`fastestFee`, into: &buf)
        FfiConverterUInt64.write(value.`halfHourFee`, into: &buf)
        FfiConverterUInt64.write(value.`hourFee`, into: &buf)
        FfiConverterUInt64.write(value.`economyFee`, into: &buf)
        FfiConverterUInt64.write(value.`minimumFee`, into: &buf)
    }
}


public func FfiConverterTypeRecommendedFees_lift(_ buf: RustBuffer) throws -> RecommendedFees {
    return try FfiConverterTypeRecommendedFees.lift(buf)
}

public func FfiConverterTypeRecommendedFees_lower(_ value: RecommendedFees) -> RustBuffer {
    return FfiConverterTypeRecommendedFees.lower(value)
}


public struct RefundRequest {
    public var `swapAddress`: String
    public var `toAddress`: String
    public var `satPerVbyte`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`swapAddress`: String, `toAddress`: String, `satPerVbyte`: UInt32) {
        self.`swapAddress` = `swapAddress`
        self.`toAddress` = `toAddress`
        self.`satPerVbyte` = `satPerVbyte`
    }
}


extension RefundRequest: Equatable, Hashable {
    public static func ==(lhs: RefundRequest, rhs: RefundRequest) -> Bool {
        if lhs.`swapAddress` != rhs.`swapAddress` {
            return false
        }
        if lhs.`toAddress` != rhs.`toAddress` {
            return false
        }
        if lhs.`satPerVbyte` != rhs.`satPerVbyte` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`swapAddress`)
        hasher.combine(`toAddress`)
        hasher.combine(`satPerVbyte`)
    }
}


public struct FfiConverterTypeRefundRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundRequest {
        return try RefundRequest(
            `swapAddress`: FfiConverterString.read(from: &buf),
            `toAddress`: FfiConverterString.read(from: &buf),
            `satPerVbyte`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: RefundRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`swapAddress`, into: &buf)
        FfiConverterString.write(value.`toAddress`, into: &buf)
        FfiConverterUInt32.write(value.`satPerVbyte`, into: &buf)
    }
}


public func FfiConverterTypeRefundRequest_lift(_ buf: RustBuffer) throws -> RefundRequest {
    return try FfiConverterTypeRefundRequest.lift(buf)
}

public func FfiConverterTypeRefundRequest_lower(_ value: RefundRequest) -> RustBuffer {
    return FfiConverterTypeRefundRequest.lower(value)
}


public struct RefundResponse {
    public var `refundTxId`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`refundTxId`: String) {
        self.`refundTxId` = `refundTxId`
    }
}


extension RefundResponse: Equatable, Hashable {
    public static func ==(lhs: RefundResponse, rhs: RefundResponse) -> Bool {
        if lhs.`refundTxId` != rhs.`refundTxId` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`refundTxId`)
    }
}


public struct FfiConverterTypeRefundResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefundResponse {
        return try RefundResponse(
            `refundTxId`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RefundResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`refundTxId`, into: &buf)
    }
}


public func FfiConverterTypeRefundResponse_lift(_ buf: RustBuffer) throws -> RefundResponse {
    return try FfiConverterTypeRefundResponse.lift(buf)
}

public func FfiConverterTypeRefundResponse_lower(_ value: RefundResponse) -> RustBuffer {
    return FfiConverterTypeRefundResponse.lower(value)
}


public struct ReportPaymentFailureDetails {
    public var `paymentHash`: String
    public var `comment`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`paymentHash`: String, `comment`: String? = nil) {
        self.`paymentHash` = `paymentHash`
        self.`comment` = `comment`
    }
}


extension ReportPaymentFailureDetails: Equatable, Hashable {
    public static func ==(lhs: ReportPaymentFailureDetails, rhs: ReportPaymentFailureDetails) -> Bool {
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`comment` != rhs.`comment` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`paymentHash`)
        hasher.combine(`comment`)
    }
}


public struct FfiConverterTypeReportPaymentFailureDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReportPaymentFailureDetails {
        return try ReportPaymentFailureDetails(
            `paymentHash`: FfiConverterString.read(from: &buf),
            `comment`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ReportPaymentFailureDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`paymentHash`, into: &buf)
        FfiConverterOptionString.write(value.`comment`, into: &buf)
    }
}


public func FfiConverterTypeReportPaymentFailureDetails_lift(_ buf: RustBuffer) throws -> ReportPaymentFailureDetails {
    return try FfiConverterTypeReportPaymentFailureDetails.lift(buf)
}

public func FfiConverterTypeReportPaymentFailureDetails_lower(_ value: ReportPaymentFailureDetails) -> RustBuffer {
    return FfiConverterTypeReportPaymentFailureDetails.lower(value)
}


public struct ReverseSwapFeesRequest {
    public var `sendAmountSat`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`sendAmountSat`: UInt64? = nil) {
        self.`sendAmountSat` = `sendAmountSat`
    }
}


extension ReverseSwapFeesRequest: Equatable, Hashable {
    public static func ==(lhs: ReverseSwapFeesRequest, rhs: ReverseSwapFeesRequest) -> Bool {
        if lhs.`sendAmountSat` != rhs.`sendAmountSat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`sendAmountSat`)
    }
}


public struct FfiConverterTypeReverseSwapFeesRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReverseSwapFeesRequest {
        return try ReverseSwapFeesRequest(
            `sendAmountSat`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ReverseSwapFeesRequest, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.`sendAmountSat`, into: &buf)
    }
}


public func FfiConverterTypeReverseSwapFeesRequest_lift(_ buf: RustBuffer) throws -> ReverseSwapFeesRequest {
    return try FfiConverterTypeReverseSwapFeesRequest.lift(buf)
}

public func FfiConverterTypeReverseSwapFeesRequest_lower(_ value: ReverseSwapFeesRequest) -> RustBuffer {
    return FfiConverterTypeReverseSwapFeesRequest.lower(value)
}


public struct ReverseSwapInfo {
    public var `id`: String
    public var `claimPubkey`: String
    public var `lockupTxid`: String?
    public var `claimTxid`: String?
    public var `onchainAmountSat`: UInt64
    public var `status`: ReverseSwapStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `claimPubkey`: String, `lockupTxid`: String?, `claimTxid`: String?, `onchainAmountSat`: UInt64, `status`: ReverseSwapStatus) {
        self.`id` = `id`
        self.`claimPubkey` = `claimPubkey`
        self.`lockupTxid` = `lockupTxid`
        self.`claimTxid` = `claimTxid`
        self.`onchainAmountSat` = `onchainAmountSat`
        self.`status` = `status`
    }
}


extension ReverseSwapInfo: Equatable, Hashable {
    public static func ==(lhs: ReverseSwapInfo, rhs: ReverseSwapInfo) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`claimPubkey` != rhs.`claimPubkey` {
            return false
        }
        if lhs.`lockupTxid` != rhs.`lockupTxid` {
            return false
        }
        if lhs.`claimTxid` != rhs.`claimTxid` {
            return false
        }
        if lhs.`onchainAmountSat` != rhs.`onchainAmountSat` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`claimPubkey`)
        hasher.combine(`lockupTxid`)
        hasher.combine(`claimTxid`)
        hasher.combine(`onchainAmountSat`)
        hasher.combine(`status`)
    }
}


public struct FfiConverterTypeReverseSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReverseSwapInfo {
        return try ReverseSwapInfo(
            `id`: FfiConverterString.read(from: &buf),
            `claimPubkey`: FfiConverterString.read(from: &buf),
            `lockupTxid`: FfiConverterOptionString.read(from: &buf),
            `claimTxid`: FfiConverterOptionString.read(from: &buf),
            `onchainAmountSat`: FfiConverterUInt64.read(from: &buf),
            `status`: FfiConverterTypeReverseSwapStatus.read(from: &buf)
        )
    }

    public static func write(_ value: ReverseSwapInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`claimPubkey`, into: &buf)
        FfiConverterOptionString.write(value.`lockupTxid`, into: &buf)
        FfiConverterOptionString.write(value.`claimTxid`, into: &buf)
        FfiConverterUInt64.write(value.`onchainAmountSat`, into: &buf)
        FfiConverterTypeReverseSwapStatus.write(value.`status`, into: &buf)
    }
}


public func FfiConverterTypeReverseSwapInfo_lift(_ buf: RustBuffer) throws -> ReverseSwapInfo {
    return try FfiConverterTypeReverseSwapInfo.lift(buf)
}

public func FfiConverterTypeReverseSwapInfo_lower(_ value: ReverseSwapInfo) -> RustBuffer {
    return FfiConverterTypeReverseSwapInfo.lower(value)
}


public struct ReverseSwapPairInfo {
    public var `min`: UInt64
    public var `max`: UInt64
    public var `feesHash`: String
    public var `feesPercentage`: Double
    public var `feesLockup`: UInt64
    public var `feesClaim`: UInt64
    public var `totalEstimatedFees`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`min`: UInt64, `max`: UInt64, `feesHash`: String, `feesPercentage`: Double, `feesLockup`: UInt64, `feesClaim`: UInt64, `totalEstimatedFees`: UInt64?) {
        self.`min` = `min`
        self.`max` = `max`
        self.`feesHash` = `feesHash`
        self.`feesPercentage` = `feesPercentage`
        self.`feesLockup` = `feesLockup`
        self.`feesClaim` = `feesClaim`
        self.`totalEstimatedFees` = `totalEstimatedFees`
    }
}


extension ReverseSwapPairInfo: Equatable, Hashable {
    public static func ==(lhs: ReverseSwapPairInfo, rhs: ReverseSwapPairInfo) -> Bool {
        if lhs.`min` != rhs.`min` {
            return false
        }
        if lhs.`max` != rhs.`max` {
            return false
        }
        if lhs.`feesHash` != rhs.`feesHash` {
            return false
        }
        if lhs.`feesPercentage` != rhs.`feesPercentage` {
            return false
        }
        if lhs.`feesLockup` != rhs.`feesLockup` {
            return false
        }
        if lhs.`feesClaim` != rhs.`feesClaim` {
            return false
        }
        if lhs.`totalEstimatedFees` != rhs.`totalEstimatedFees` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`min`)
        hasher.combine(`max`)
        hasher.combine(`feesHash`)
        hasher.combine(`feesPercentage`)
        hasher.combine(`feesLockup`)
        hasher.combine(`feesClaim`)
        hasher.combine(`totalEstimatedFees`)
    }
}


public struct FfiConverterTypeReverseSwapPairInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReverseSwapPairInfo {
        return try ReverseSwapPairInfo(
            `min`: FfiConverterUInt64.read(from: &buf),
            `max`: FfiConverterUInt64.read(from: &buf),
            `feesHash`: FfiConverterString.read(from: &buf),
            `feesPercentage`: FfiConverterDouble.read(from: &buf),
            `feesLockup`: FfiConverterUInt64.read(from: &buf),
            `feesClaim`: FfiConverterUInt64.read(from: &buf),
            `totalEstimatedFees`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ReverseSwapPairInfo, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`min`, into: &buf)
        FfiConverterUInt64.write(value.`max`, into: &buf)
        FfiConverterString.write(value.`feesHash`, into: &buf)
        FfiConverterDouble.write(value.`feesPercentage`, into: &buf)
        FfiConverterUInt64.write(value.`feesLockup`, into: &buf)
        FfiConverterUInt64.write(value.`feesClaim`, into: &buf)
        FfiConverterOptionUInt64.write(value.`totalEstimatedFees`, into: &buf)
    }
}


public func FfiConverterTypeReverseSwapPairInfo_lift(_ buf: RustBuffer) throws -> ReverseSwapPairInfo {
    return try FfiConverterTypeReverseSwapPairInfo.lift(buf)
}

public func FfiConverterTypeReverseSwapPairInfo_lower(_ value: ReverseSwapPairInfo) -> RustBuffer {
    return FfiConverterTypeReverseSwapPairInfo.lower(value)
}


public struct RouteHint {
    public var `hops`: [RouteHintHop]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`hops`: [RouteHintHop]) {
        self.`hops` = `hops`
    }
}


extension RouteHint: Equatable, Hashable {
    public static func ==(lhs: RouteHint, rhs: RouteHint) -> Bool {
        if lhs.`hops` != rhs.`hops` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`hops`)
    }
}


public struct FfiConverterTypeRouteHint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteHint {
        return try RouteHint(
            `hops`: FfiConverterSequenceTypeRouteHintHop.read(from: &buf)
        )
    }

    public static func write(_ value: RouteHint, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeRouteHintHop.write(value.`hops`, into: &buf)
    }
}


public func FfiConverterTypeRouteHint_lift(_ buf: RustBuffer) throws -> RouteHint {
    return try FfiConverterTypeRouteHint.lift(buf)
}

public func FfiConverterTypeRouteHint_lower(_ value: RouteHint) -> RustBuffer {
    return FfiConverterTypeRouteHint.lower(value)
}


public struct RouteHintHop {
    public var `srcNodeId`: String
    public var `shortChannelId`: UInt64
    public var `feesBaseMsat`: UInt32
    public var `feesProportionalMillionths`: UInt32
    public var `cltvExpiryDelta`: UInt64
    public var `htlcMinimumMsat`: UInt64?
    public var `htlcMaximumMsat`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`srcNodeId`: String, `shortChannelId`: UInt64, `feesBaseMsat`: UInt32, `feesProportionalMillionths`: UInt32, `cltvExpiryDelta`: UInt64, `htlcMinimumMsat`: UInt64?, `htlcMaximumMsat`: UInt64?) {
        self.`srcNodeId` = `srcNodeId`
        self.`shortChannelId` = `shortChannelId`
        self.`feesBaseMsat` = `feesBaseMsat`
        self.`feesProportionalMillionths` = `feesProportionalMillionths`
        self.`cltvExpiryDelta` = `cltvExpiryDelta`
        self.`htlcMinimumMsat` = `htlcMinimumMsat`
        self.`htlcMaximumMsat` = `htlcMaximumMsat`
    }
}


extension RouteHintHop: Equatable, Hashable {
    public static func ==(lhs: RouteHintHop, rhs: RouteHintHop) -> Bool {
        if lhs.`srcNodeId` != rhs.`srcNodeId` {
            return false
        }
        if lhs.`shortChannelId` != rhs.`shortChannelId` {
            return false
        }
        if lhs.`feesBaseMsat` != rhs.`feesBaseMsat` {
            return false
        }
        if lhs.`feesProportionalMillionths` != rhs.`feesProportionalMillionths` {
            return false
        }
        if lhs.`cltvExpiryDelta` != rhs.`cltvExpiryDelta` {
            return false
        }
        if lhs.`htlcMinimumMsat` != rhs.`htlcMinimumMsat` {
            return false
        }
        if lhs.`htlcMaximumMsat` != rhs.`htlcMaximumMsat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`srcNodeId`)
        hasher.combine(`shortChannelId`)
        hasher.combine(`feesBaseMsat`)
        hasher.combine(`feesProportionalMillionths`)
        hasher.combine(`cltvExpiryDelta`)
        hasher.combine(`htlcMinimumMsat`)
        hasher.combine(`htlcMaximumMsat`)
    }
}


public struct FfiConverterTypeRouteHintHop: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RouteHintHop {
        return try RouteHintHop(
            `srcNodeId`: FfiConverterString.read(from: &buf),
            `shortChannelId`: FfiConverterUInt64.read(from: &buf),
            `feesBaseMsat`: FfiConverterUInt32.read(from: &buf),
            `feesProportionalMillionths`: FfiConverterUInt32.read(from: &buf),
            `cltvExpiryDelta`: FfiConverterUInt64.read(from: &buf),
            `htlcMinimumMsat`: FfiConverterOptionUInt64.read(from: &buf),
            `htlcMaximumMsat`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RouteHintHop, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`srcNodeId`, into: &buf)
        FfiConverterUInt64.write(value.`shortChannelId`, into: &buf)
        FfiConverterUInt32.write(value.`feesBaseMsat`, into: &buf)
        FfiConverterUInt32.write(value.`feesProportionalMillionths`, into: &buf)
        FfiConverterUInt64.write(value.`cltvExpiryDelta`, into: &buf)
        FfiConverterOptionUInt64.write(value.`htlcMinimumMsat`, into: &buf)
        FfiConverterOptionUInt64.write(value.`htlcMaximumMsat`, into: &buf)
    }
}


public func FfiConverterTypeRouteHintHop_lift(_ buf: RustBuffer) throws -> RouteHintHop {
    return try FfiConverterTypeRouteHintHop.lift(buf)
}

public func FfiConverterTypeRouteHintHop_lower(_ value: RouteHintHop) -> RustBuffer {
    return FfiConverterTypeRouteHintHop.lower(value)
}


public struct SendOnchainRequest {
    public var `amountSat`: UInt64
    public var `onchainRecipientAddress`: String
    public var `pairHash`: String
    public var `satPerVbyte`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`amountSat`: UInt64, `onchainRecipientAddress`: String, `pairHash`: String, `satPerVbyte`: UInt32) {
        self.`amountSat` = `amountSat`
        self.`onchainRecipientAddress` = `onchainRecipientAddress`
        self.`pairHash` = `pairHash`
        self.`satPerVbyte` = `satPerVbyte`
    }
}


extension SendOnchainRequest: Equatable, Hashable {
    public static func ==(lhs: SendOnchainRequest, rhs: SendOnchainRequest) -> Bool {
        if lhs.`amountSat` != rhs.`amountSat` {
            return false
        }
        if lhs.`onchainRecipientAddress` != rhs.`onchainRecipientAddress` {
            return false
        }
        if lhs.`pairHash` != rhs.`pairHash` {
            return false
        }
        if lhs.`satPerVbyte` != rhs.`satPerVbyte` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`amountSat`)
        hasher.combine(`onchainRecipientAddress`)
        hasher.combine(`pairHash`)
        hasher.combine(`satPerVbyte`)
    }
}


public struct FfiConverterTypeSendOnchainRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainRequest {
        return try SendOnchainRequest(
            `amountSat`: FfiConverterUInt64.read(from: &buf),
            `onchainRecipientAddress`: FfiConverterString.read(from: &buf),
            `pairHash`: FfiConverterString.read(from: &buf),
            `satPerVbyte`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainRequest, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`amountSat`, into: &buf)
        FfiConverterString.write(value.`onchainRecipientAddress`, into: &buf)
        FfiConverterString.write(value.`pairHash`, into: &buf)
        FfiConverterUInt32.write(value.`satPerVbyte`, into: &buf)
    }
}


public func FfiConverterTypeSendOnchainRequest_lift(_ buf: RustBuffer) throws -> SendOnchainRequest {
    return try FfiConverterTypeSendOnchainRequest.lift(buf)
}

public func FfiConverterTypeSendOnchainRequest_lower(_ value: SendOnchainRequest) -> RustBuffer {
    return FfiConverterTypeSendOnchainRequest.lower(value)
}


public struct SendOnchainResponse {
    public var `reverseSwapInfo`: ReverseSwapInfo

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`reverseSwapInfo`: ReverseSwapInfo) {
        self.`reverseSwapInfo` = `reverseSwapInfo`
    }
}


extension SendOnchainResponse: Equatable, Hashable {
    public static func ==(lhs: SendOnchainResponse, rhs: SendOnchainResponse) -> Bool {
        if lhs.`reverseSwapInfo` != rhs.`reverseSwapInfo` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`reverseSwapInfo`)
    }
}


public struct FfiConverterTypeSendOnchainResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainResponse {
        return try SendOnchainResponse(
            `reverseSwapInfo`: FfiConverterTypeReverseSwapInfo.read(from: &buf)
        )
    }

    public static func write(_ value: SendOnchainResponse, into buf: inout [UInt8]) {
        FfiConverterTypeReverseSwapInfo.write(value.`reverseSwapInfo`, into: &buf)
    }
}


public func FfiConverterTypeSendOnchainResponse_lift(_ buf: RustBuffer) throws -> SendOnchainResponse {
    return try FfiConverterTypeSendOnchainResponse.lift(buf)
}

public func FfiConverterTypeSendOnchainResponse_lower(_ value: SendOnchainResponse) -> RustBuffer {
    return FfiConverterTypeSendOnchainResponse.lower(value)
}


public struct SendPaymentRequest {
    public var `bolt11`: String
    public var `amountMsat`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`bolt11`: String, `amountMsat`: UInt64? = nil) {
        self.`bolt11` = `bolt11`
        self.`amountMsat` = `amountMsat`
    }
}


extension SendPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: SendPaymentRequest, rhs: SendPaymentRequest) -> Bool {
        if lhs.`bolt11` != rhs.`bolt11` {
            return false
        }
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`bolt11`)
        hasher.combine(`amountMsat`)
    }
}


public struct FfiConverterTypeSendPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentRequest {
        return try SendPaymentRequest(
            `bolt11`: FfiConverterString.read(from: &buf),
            `amountMsat`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`bolt11`, into: &buf)
        FfiConverterOptionUInt64.write(value.`amountMsat`, into: &buf)
    }
}


public func FfiConverterTypeSendPaymentRequest_lift(_ buf: RustBuffer) throws -> SendPaymentRequest {
    return try FfiConverterTypeSendPaymentRequest.lift(buf)
}

public func FfiConverterTypeSendPaymentRequest_lower(_ value: SendPaymentRequest) -> RustBuffer {
    return FfiConverterTypeSendPaymentRequest.lower(value)
}


public struct SendPaymentResponse {
    public var `payment`: Payment

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`payment`: Payment) {
        self.`payment` = `payment`
    }
}


extension SendPaymentResponse: Equatable, Hashable {
    public static func ==(lhs: SendPaymentResponse, rhs: SendPaymentResponse) -> Bool {
        if lhs.`payment` != rhs.`payment` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`payment`)
    }
}


public struct FfiConverterTypeSendPaymentResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentResponse {
        return try SendPaymentResponse(
            `payment`: FfiConverterTypePayment.read(from: &buf)
        )
    }

    public static func write(_ value: SendPaymentResponse, into buf: inout [UInt8]) {
        FfiConverterTypePayment.write(value.`payment`, into: &buf)
    }
}


public func FfiConverterTypeSendPaymentResponse_lift(_ buf: RustBuffer) throws -> SendPaymentResponse {
    return try FfiConverterTypeSendPaymentResponse.lift(buf)
}

public func FfiConverterTypeSendPaymentResponse_lower(_ value: SendPaymentResponse) -> RustBuffer {
    return FfiConverterTypeSendPaymentResponse.lower(value)
}


public struct SendSpontaneousPaymentRequest {
    public var `nodeId`: String
    public var `amountMsat`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`nodeId`: String, `amountMsat`: UInt64) {
        self.`nodeId` = `nodeId`
        self.`amountMsat` = `amountMsat`
    }
}


extension SendSpontaneousPaymentRequest: Equatable, Hashable {
    public static func ==(lhs: SendSpontaneousPaymentRequest, rhs: SendSpontaneousPaymentRequest) -> Bool {
        if lhs.`nodeId` != rhs.`nodeId` {
            return false
        }
        if lhs.`amountMsat` != rhs.`amountMsat` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`nodeId`)
        hasher.combine(`amountMsat`)
    }
}


public struct FfiConverterTypeSendSpontaneousPaymentRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendSpontaneousPaymentRequest {
        return try SendSpontaneousPaymentRequest(
            `nodeId`: FfiConverterString.read(from: &buf),
            `amountMsat`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SendSpontaneousPaymentRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`nodeId`, into: &buf)
        FfiConverterUInt64.write(value.`amountMsat`, into: &buf)
    }
}


public func FfiConverterTypeSendSpontaneousPaymentRequest_lift(_ buf: RustBuffer) throws -> SendSpontaneousPaymentRequest {
    return try FfiConverterTypeSendSpontaneousPaymentRequest.lift(buf)
}

public func FfiConverterTypeSendSpontaneousPaymentRequest_lower(_ value: SendSpontaneousPaymentRequest) -> RustBuffer {
    return FfiConverterTypeSendSpontaneousPaymentRequest.lower(value)
}


public struct ServiceHealthCheckResponse {
    public var `status`: HealthCheckStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`status`: HealthCheckStatus) {
        self.`status` = `status`
    }
}


extension ServiceHealthCheckResponse: Equatable, Hashable {
    public static func ==(lhs: ServiceHealthCheckResponse, rhs: ServiceHealthCheckResponse) -> Bool {
        if lhs.`status` != rhs.`status` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`status`)
    }
}


public struct FfiConverterTypeServiceHealthCheckResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServiceHealthCheckResponse {
        return try ServiceHealthCheckResponse(
            `status`: FfiConverterTypeHealthCheckStatus.read(from: &buf)
        )
    }

    public static func write(_ value: ServiceHealthCheckResponse, into buf: inout [UInt8]) {
        FfiConverterTypeHealthCheckStatus.write(value.`status`, into: &buf)
    }
}


public func FfiConverterTypeServiceHealthCheckResponse_lift(_ buf: RustBuffer) throws -> ServiceHealthCheckResponse {
    return try FfiConverterTypeServiceHealthCheckResponse.lift(buf)
}

public func FfiConverterTypeServiceHealthCheckResponse_lower(_ value: ServiceHealthCheckResponse) -> RustBuffer {
    return FfiConverterTypeServiceHealthCheckResponse.lower(value)
}


public struct SignMessageRequest {
    public var `message`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`message`: String) {
        self.`message` = `message`
    }
}


extension SignMessageRequest: Equatable, Hashable {
    public static func ==(lhs: SignMessageRequest, rhs: SignMessageRequest) -> Bool {
        if lhs.`message` != rhs.`message` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`message`)
    }
}


public struct FfiConverterTypeSignMessageRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignMessageRequest {
        return try SignMessageRequest(
            `message`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignMessageRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`message`, into: &buf)
    }
}


public func FfiConverterTypeSignMessageRequest_lift(_ buf: RustBuffer) throws -> SignMessageRequest {
    return try FfiConverterTypeSignMessageRequest.lift(buf)
}

public func FfiConverterTypeSignMessageRequest_lower(_ value: SignMessageRequest) -> RustBuffer {
    return FfiConverterTypeSignMessageRequest.lower(value)
}


public struct SignMessageResponse {
    public var `signature`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`signature`: String) {
        self.`signature` = `signature`
    }
}


extension SignMessageResponse: Equatable, Hashable {
    public static func ==(lhs: SignMessageResponse, rhs: SignMessageResponse) -> Bool {
        if lhs.`signature` != rhs.`signature` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`signature`)
    }
}


public struct FfiConverterTypeSignMessageResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignMessageResponse {
        return try SignMessageResponse(
            `signature`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SignMessageResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`signature`, into: &buf)
    }
}


public func FfiConverterTypeSignMessageResponse_lift(_ buf: RustBuffer) throws -> SignMessageResponse {
    return try FfiConverterTypeSignMessageResponse.lift(buf)
}

public func FfiConverterTypeSignMessageResponse_lower(_ value: SignMessageResponse) -> RustBuffer {
    return FfiConverterTypeSignMessageResponse.lower(value)
}


public struct StaticBackupRequest {
    public var `workingDir`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`workingDir`: String) {
        self.`workingDir` = `workingDir`
    }
}


extension StaticBackupRequest: Equatable, Hashable {
    public static func ==(lhs: StaticBackupRequest, rhs: StaticBackupRequest) -> Bool {
        if lhs.`workingDir` != rhs.`workingDir` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`workingDir`)
    }
}


public struct FfiConverterTypeStaticBackupRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StaticBackupRequest {
        return try StaticBackupRequest(
            `workingDir`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: StaticBackupRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`workingDir`, into: &buf)
    }
}


public func FfiConverterTypeStaticBackupRequest_lift(_ buf: RustBuffer) throws -> StaticBackupRequest {
    return try FfiConverterTypeStaticBackupRequest.lift(buf)
}

public func FfiConverterTypeStaticBackupRequest_lower(_ value: StaticBackupRequest) -> RustBuffer {
    return FfiConverterTypeStaticBackupRequest.lower(value)
}


public struct StaticBackupResponse {
    public var `backup`: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`backup`: [String]?) {
        self.`backup` = `backup`
    }
}


extension StaticBackupResponse: Equatable, Hashable {
    public static func ==(lhs: StaticBackupResponse, rhs: StaticBackupResponse) -> Bool {
        if lhs.`backup` != rhs.`backup` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`backup`)
    }
}


public struct FfiConverterTypeStaticBackupResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StaticBackupResponse {
        return try StaticBackupResponse(
            `backup`: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: StaticBackupResponse, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceString.write(value.`backup`, into: &buf)
    }
}


public func FfiConverterTypeStaticBackupResponse_lift(_ buf: RustBuffer) throws -> StaticBackupResponse {
    return try FfiConverterTypeStaticBackupResponse.lift(buf)
}

public func FfiConverterTypeStaticBackupResponse_lower(_ value: StaticBackupResponse) -> RustBuffer {
    return FfiConverterTypeStaticBackupResponse.lower(value)
}


public struct SwapInfo {
    public var `bitcoinAddress`: String
    public var `createdAt`: Int64
    public var `lockHeight`: Int64
    public var `paymentHash`: [UInt8]
    public var `preimage`: [UInt8]
    public var `privateKey`: [UInt8]
    public var `publicKey`: [UInt8]
    public var `swapperPublicKey`: [UInt8]
    public var `script`: [UInt8]
    public var `bolt11`: String?
    public var `paidSats`: UInt64
    public var `unconfirmedSats`: UInt64
    public var `confirmedSats`: UInt64
    public var `status`: SwapStatus
    public var `refundTxIds`: [String]
    public var `unconfirmedTxIds`: [String]
    public var `confirmedTxIds`: [String]
    public var `minAllowedDeposit`: Int64
    public var `maxAllowedDeposit`: Int64
    public var `lastRedeemError`: String?
    public var `channelOpeningFees`: OpeningFeeParams?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`bitcoinAddress`: String, `createdAt`: Int64, `lockHeight`: Int64, `paymentHash`: [UInt8], `preimage`: [UInt8], `privateKey`: [UInt8], `publicKey`: [UInt8], `swapperPublicKey`: [UInt8], `script`: [UInt8], `bolt11`: String?, `paidSats`: UInt64, `unconfirmedSats`: UInt64, `confirmedSats`: UInt64, `status`: SwapStatus, `refundTxIds`: [String], `unconfirmedTxIds`: [String], `confirmedTxIds`: [String], `minAllowedDeposit`: Int64, `maxAllowedDeposit`: Int64, `lastRedeemError`: String?, `channelOpeningFees`: OpeningFeeParams?) {
        self.`bitcoinAddress` = `bitcoinAddress`
        self.`createdAt` = `createdAt`
        self.`lockHeight` = `lockHeight`
        self.`paymentHash` = `paymentHash`
        self.`preimage` = `preimage`
        self.`privateKey` = `privateKey`
        self.`publicKey` = `publicKey`
        self.`swapperPublicKey` = `swapperPublicKey`
        self.`script` = `script`
        self.`bolt11` = `bolt11`
        self.`paidSats` = `paidSats`
        self.`unconfirmedSats` = `unconfirmedSats`
        self.`confirmedSats` = `confirmedSats`
        self.`status` = `status`
        self.`refundTxIds` = `refundTxIds`
        self.`unconfirmedTxIds` = `unconfirmedTxIds`
        self.`confirmedTxIds` = `confirmedTxIds`
        self.`minAllowedDeposit` = `minAllowedDeposit`
        self.`maxAllowedDeposit` = `maxAllowedDeposit`
        self.`lastRedeemError` = `lastRedeemError`
        self.`channelOpeningFees` = `channelOpeningFees`
    }
}


extension SwapInfo: Equatable, Hashable {
    public static func ==(lhs: SwapInfo, rhs: SwapInfo) -> Bool {
        if lhs.`bitcoinAddress` != rhs.`bitcoinAddress` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`lockHeight` != rhs.`lockHeight` {
            return false
        }
        if lhs.`paymentHash` != rhs.`paymentHash` {
            return false
        }
        if lhs.`preimage` != rhs.`preimage` {
            return false
        }
        if lhs.`privateKey` != rhs.`privateKey` {
            return false
        }
        if lhs.`publicKey` != rhs.`publicKey` {
            return false
        }
        if lhs.`swapperPublicKey` != rhs.`swapperPublicKey` {
            return false
        }
        if lhs.`script` != rhs.`script` {
            return false
        }
        if lhs.`bolt11` != rhs.`bolt11` {
            return false
        }
        if lhs.`paidSats` != rhs.`paidSats` {
            return false
        }
        if lhs.`unconfirmedSats` != rhs.`unconfirmedSats` {
            return false
        }
        if lhs.`confirmedSats` != rhs.`confirmedSats` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        if lhs.`refundTxIds` != rhs.`refundTxIds` {
            return false
        }
        if lhs.`unconfirmedTxIds` != rhs.`unconfirmedTxIds` {
            return false
        }
        if lhs.`confirmedTxIds` != rhs.`confirmedTxIds` {
            return false
        }
        if lhs.`minAllowedDeposit` != rhs.`minAllowedDeposit` {
            return false
        }
        if lhs.`maxAllowedDeposit` != rhs.`maxAllowedDeposit` {
            return false
        }
        if lhs.`lastRedeemError` != rhs.`lastRedeemError` {
            return false
        }
        if lhs.`channelOpeningFees` != rhs.`channelOpeningFees` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`bitcoinAddress`)
        hasher.combine(`createdAt`)
        hasher.combine(`lockHeight`)
        hasher.combine(`paymentHash`)
        hasher.combine(`preimage`)
        hasher.combine(`privateKey`)
        hasher.combine(`publicKey`)
        hasher.combine(`swapperPublicKey`)
        hasher.combine(`script`)
        hasher.combine(`bolt11`)
        hasher.combine(`paidSats`)
        hasher.combine(`unconfirmedSats`)
        hasher.combine(`confirmedSats`)
        hasher.combine(`status`)
        hasher.combine(`refundTxIds`)
        hasher.combine(`unconfirmedTxIds`)
        hasher.combine(`confirmedTxIds`)
        hasher.combine(`minAllowedDeposit`)
        hasher.combine(`maxAllowedDeposit`)
        hasher.combine(`lastRedeemError`)
        hasher.combine(`channelOpeningFees`)
    }
}


public struct FfiConverterTypeSwapInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapInfo {
        return try SwapInfo(
            `bitcoinAddress`: FfiConverterString.read(from: &buf),
            `createdAt`: FfiConverterInt64.read(from: &buf),
            `lockHeight`: FfiConverterInt64.read(from: &buf),
            `paymentHash`: FfiConverterSequenceUInt8.read(from: &buf),
            `preimage`: FfiConverterSequenceUInt8.read(from: &buf),
            `privateKey`: FfiConverterSequenceUInt8.read(from: &buf),
            `publicKey`: FfiConverterSequenceUInt8.read(from: &buf),
            `swapperPublicKey`: FfiConverterSequenceUInt8.read(from: &buf),
            `script`: FfiConverterSequenceUInt8.read(from: &buf),
            `bolt11`: FfiConverterOptionString.read(from: &buf),
            `paidSats`: FfiConverterUInt64.read(from: &buf),
            `unconfirmedSats`: FfiConverterUInt64.read(from: &buf),
            `confirmedSats`: FfiConverterUInt64.read(from: &buf),
            `status`: FfiConverterTypeSwapStatus.read(from: &buf),
            `refundTxIds`: FfiConverterSequenceString.read(from: &buf),
            `unconfirmedTxIds`: FfiConverterSequenceString.read(from: &buf),
            `confirmedTxIds`: FfiConverterSequenceString.read(from: &buf),
            `minAllowedDeposit`: FfiConverterInt64.read(from: &buf),
            `maxAllowedDeposit`: FfiConverterInt64.read(from: &buf),
            `lastRedeemError`: FfiConverterOptionString.read(from: &buf),
            `channelOpeningFees`: FfiConverterOptionTypeOpeningFeeParams.read(from: &buf)
        )
    }

    public static func write(_ value: SwapInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`bitcoinAddress`, into: &buf)
        FfiConverterInt64.write(value.`createdAt`, into: &buf)
        FfiConverterInt64.write(value.`lockHeight`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`paymentHash`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`preimage`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`privateKey`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`publicKey`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`swapperPublicKey`, into: &buf)
        FfiConverterSequenceUInt8.write(value.`script`, into: &buf)
        FfiConverterOptionString.write(value.`bolt11`, into: &buf)
        FfiConverterUInt64.write(value.`paidSats`, into: &buf)
        FfiConverterUInt64.write(value.`unconfirmedSats`, into: &buf)
        FfiConverterUInt64.write(value.`confirmedSats`, into: &buf)
        FfiConverterTypeSwapStatus.write(value.`status`, into: &buf)
        FfiConverterSequenceString.write(value.`refundTxIds`, into: &buf)
        FfiConverterSequenceString.write(value.`unconfirmedTxIds`, into: &buf)
        FfiConverterSequenceString.write(value.`confirmedTxIds`, into: &buf)
        FfiConverterInt64.write(value.`minAllowedDeposit`, into: &buf)
        FfiConverterInt64.write(value.`maxAllowedDeposit`, into: &buf)
        FfiConverterOptionString.write(value.`lastRedeemError`, into: &buf)
        FfiConverterOptionTypeOpeningFeeParams.write(value.`channelOpeningFees`, into: &buf)
    }
}


public func FfiConverterTypeSwapInfo_lift(_ buf: RustBuffer) throws -> SwapInfo {
    return try FfiConverterTypeSwapInfo.lift(buf)
}

public func FfiConverterTypeSwapInfo_lower(_ value: SwapInfo) -> RustBuffer {
    return FfiConverterTypeSwapInfo.lower(value)
}


public struct SweepRequest {
    public var `toAddress`: String
    public var `satPerVbyte`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`toAddress`: String, `satPerVbyte`: UInt32) {
        self.`toAddress` = `toAddress`
        self.`satPerVbyte` = `satPerVbyte`
    }
}


extension SweepRequest: Equatable, Hashable {
    public static func ==(lhs: SweepRequest, rhs: SweepRequest) -> Bool {
        if lhs.`toAddress` != rhs.`toAddress` {
            return false
        }
        if lhs.`satPerVbyte` != rhs.`satPerVbyte` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`toAddress`)
        hasher.combine(`satPerVbyte`)
    }
}


public struct FfiConverterTypeSweepRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SweepRequest {
        return try SweepRequest(
            `toAddress`: FfiConverterString.read(from: &buf),
            `satPerVbyte`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: SweepRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`toAddress`, into: &buf)
        FfiConverterUInt32.write(value.`satPerVbyte`, into: &buf)
    }
}


public func FfiConverterTypeSweepRequest_lift(_ buf: RustBuffer) throws -> SweepRequest {
    return try FfiConverterTypeSweepRequest.lift(buf)
}

public func FfiConverterTypeSweepRequest_lower(_ value: SweepRequest) -> RustBuffer {
    return FfiConverterTypeSweepRequest.lower(value)
}


public struct SweepResponse {
    public var `txid`: [UInt8]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`txid`: [UInt8]) {
        self.`txid` = `txid`
    }
}


extension SweepResponse: Equatable, Hashable {
    public static func ==(lhs: SweepResponse, rhs: SweepResponse) -> Bool {
        if lhs.`txid` != rhs.`txid` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`txid`)
    }
}


public struct FfiConverterTypeSweepResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SweepResponse {
        return try SweepResponse(
            `txid`: FfiConverterSequenceUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: SweepResponse, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.`txid`, into: &buf)
    }
}


public func FfiConverterTypeSweepResponse_lift(_ buf: RustBuffer) throws -> SweepResponse {
    return try FfiConverterTypeSweepResponse.lift(buf)
}

public func FfiConverterTypeSweepResponse_lower(_ value: SweepResponse) -> RustBuffer {
    return FfiConverterTypeSweepResponse.lower(value)
}


public struct Symbol {
    public var `grapheme`: String?
    public var `template`: String?
    public var `rtl`: Bool?
    public var `position`: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`grapheme`: String?, `template`: String?, `rtl`: Bool?, `position`: UInt32?) {
        self.`grapheme` = `grapheme`
        self.`template` = `template`
        self.`rtl` = `rtl`
        self.`position` = `position`
    }
}


extension Symbol: Equatable, Hashable {
    public static func ==(lhs: Symbol, rhs: Symbol) -> Bool {
        if lhs.`grapheme` != rhs.`grapheme` {
            return false
        }
        if lhs.`template` != rhs.`template` {
            return false
        }
        if lhs.`rtl` != rhs.`rtl` {
            return false
        }
        if lhs.`position` != rhs.`position` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`grapheme`)
        hasher.combine(`template`)
        hasher.combine(`rtl`)
        hasher.combine(`position`)
    }
}


public struct FfiConverterTypeSymbol: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Symbol {
        return try Symbol(
            `grapheme`: FfiConverterOptionString.read(from: &buf),
            `template`: FfiConverterOptionString.read(from: &buf),
            `rtl`: FfiConverterOptionBool.read(from: &buf),
            `position`: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Symbol, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`grapheme`, into: &buf)
        FfiConverterOptionString.write(value.`template`, into: &buf)
        FfiConverterOptionBool.write(value.`rtl`, into: &buf)
        FfiConverterOptionUInt32.write(value.`position`, into: &buf)
    }
}


public func FfiConverterTypeSymbol_lift(_ buf: RustBuffer) throws -> Symbol {
    return try FfiConverterTypeSymbol.lift(buf)
}

public func FfiConverterTypeSymbol_lower(_ value: Symbol) -> RustBuffer {
    return FfiConverterTypeSymbol.lower(value)
}


public struct UnspentTransactionOutput {
    public var `txid`: [UInt8]
    public var `outnum`: UInt32
    public var `amountMillisatoshi`: UInt64
    public var `address`: String
    public var `reserved`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`txid`: [UInt8], `outnum`: UInt32, `amountMillisatoshi`: UInt64, `address`: String, `reserved`: Bool) {
        self.`txid` = `txid`
        self.`outnum` = `outnum`
        self.`amountMillisatoshi` = `amountMillisatoshi`
        self.`address` = `address`
        self.`reserved` = `reserved`
    }
}


extension UnspentTransactionOutput: Equatable, Hashable {
    public static func ==(lhs: UnspentTransactionOutput, rhs: UnspentTransactionOutput) -> Bool {
        if lhs.`txid` != rhs.`txid` {
            return false
        }
        if lhs.`outnum` != rhs.`outnum` {
            return false
        }
        if lhs.`amountMillisatoshi` != rhs.`amountMillisatoshi` {
            return false
        }
        if lhs.`address` != rhs.`address` {
            return false
        }
        if lhs.`reserved` != rhs.`reserved` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`txid`)
        hasher.combine(`outnum`)
        hasher.combine(`amountMillisatoshi`)
        hasher.combine(`address`)
        hasher.combine(`reserved`)
    }
}


public struct FfiConverterTypeUnspentTransactionOutput: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnspentTransactionOutput {
        return try UnspentTransactionOutput(
            `txid`: FfiConverterSequenceUInt8.read(from: &buf),
            `outnum`: FfiConverterUInt32.read(from: &buf),
            `amountMillisatoshi`: FfiConverterUInt64.read(from: &buf),
            `address`: FfiConverterString.read(from: &buf),
            `reserved`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: UnspentTransactionOutput, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt8.write(value.`txid`, into: &buf)
        FfiConverterUInt32.write(value.`outnum`, into: &buf)
        FfiConverterUInt64.write(value.`amountMillisatoshi`, into: &buf)
        FfiConverterString.write(value.`address`, into: &buf)
        FfiConverterBool.write(value.`reserved`, into: &buf)
    }
}


public func FfiConverterTypeUnspentTransactionOutput_lift(_ buf: RustBuffer) throws -> UnspentTransactionOutput {
    return try FfiConverterTypeUnspentTransactionOutput.lift(buf)
}

public func FfiConverterTypeUnspentTransactionOutput_lower(_ value: UnspentTransactionOutput) -> RustBuffer {
    return FfiConverterTypeUnspentTransactionOutput.lower(value)
}


public struct UrlSuccessActionData {
    public var `description`: String
    public var `url`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`description`: String, `url`: String) {
        self.`description` = `description`
        self.`url` = `url`
    }
}


extension UrlSuccessActionData: Equatable, Hashable {
    public static func ==(lhs: UrlSuccessActionData, rhs: UrlSuccessActionData) -> Bool {
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`url` != rhs.`url` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`description`)
        hasher.combine(`url`)
    }
}


public struct FfiConverterTypeUrlSuccessActionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UrlSuccessActionData {
        return try UrlSuccessActionData(
            `description`: FfiConverterString.read(from: &buf),
            `url`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UrlSuccessActionData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`description`, into: &buf)
        FfiConverterString.write(value.`url`, into: &buf)
    }
}


public func FfiConverterTypeUrlSuccessActionData_lift(_ buf: RustBuffer) throws -> UrlSuccessActionData {
    return try FfiConverterTypeUrlSuccessActionData.lift(buf)
}

public func FfiConverterTypeUrlSuccessActionData_lower(_ value: UrlSuccessActionData) -> RustBuffer {
    return FfiConverterTypeUrlSuccessActionData.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AesSuccessActionDataResult {
    
    case `decrypted`(`data`: AesSuccessActionDataDecrypted)
    case `errorStatus`(`reason`: String)
}

public struct FfiConverterTypeAesSuccessActionDataResult: FfiConverterRustBuffer {
    typealias SwiftType = AesSuccessActionDataResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AesSuccessActionDataResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`decrypted`(
            `data`: try FfiConverterTypeAesSuccessActionDataDecrypted.read(from: &buf)
        )
        
        case 2: return .`errorStatus`(
            `reason`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AesSuccessActionDataResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`decrypted`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataDecrypted.write(`data`, into: &buf)
            
        
        case let .`errorStatus`(`reason`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`reason`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAesSuccessActionDataResult_lift(_ buf: RustBuffer) throws -> AesSuccessActionDataResult {
    return try FfiConverterTypeAesSuccessActionDataResult.lift(buf)
}

public func FfiConverterTypeAesSuccessActionDataResult_lower(_ value: AesSuccessActionDataResult) -> RustBuffer {
    return FfiConverterTypeAesSuccessActionDataResult.lower(value)
}


extension AesSuccessActionDataResult: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BreezEvent {
    
    case `newBlock`(`block`: UInt32)
    case `invoicePaid`(`details`: InvoicePaidDetails)
    case `synced`
    case `paymentSucceed`(`details`: Payment)
    case `paymentFailed`(`details`: PaymentFailedData)
    case `backupStarted`
    case `backupSucceeded`
    case `backupFailed`(`details`: BackupFailedData)
}

public struct FfiConverterTypeBreezEvent: FfiConverterRustBuffer {
    typealias SwiftType = BreezEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BreezEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`newBlock`(
            `block`: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 2: return .`invoicePaid`(
            `details`: try FfiConverterTypeInvoicePaidDetails.read(from: &buf)
        )
        
        case 3: return .`synced`
        
        case 4: return .`paymentSucceed`(
            `details`: try FfiConverterTypePayment.read(from: &buf)
        )
        
        case 5: return .`paymentFailed`(
            `details`: try FfiConverterTypePaymentFailedData.read(from: &buf)
        )
        
        case 6: return .`backupStarted`
        
        case 7: return .`backupSucceeded`
        
        case 8: return .`backupFailed`(
            `details`: try FfiConverterTypeBackupFailedData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BreezEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`newBlock`(`block`):
            writeInt(&buf, Int32(1))
            FfiConverterUInt32.write(`block`, into: &buf)
            
        
        case let .`invoicePaid`(`details`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeInvoicePaidDetails.write(`details`, into: &buf)
            
        
        case .`synced`:
            writeInt(&buf, Int32(3))
        
        
        case let .`paymentSucceed`(`details`):
            writeInt(&buf, Int32(4))
            FfiConverterTypePayment.write(`details`, into: &buf)
            
        
        case let .`paymentFailed`(`details`):
            writeInt(&buf, Int32(5))
            FfiConverterTypePaymentFailedData.write(`details`, into: &buf)
            
        
        case .`backupStarted`:
            writeInt(&buf, Int32(6))
        
        
        case .`backupSucceeded`:
            writeInt(&buf, Int32(7))
        
        
        case let .`backupFailed`(`details`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeBackupFailedData.write(`details`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeBreezEvent_lift(_ buf: RustBuffer) throws -> BreezEvent {
    return try FfiConverterTypeBreezEvent.lift(buf)
}

public func FfiConverterTypeBreezEvent_lower(_ value: BreezEvent) -> RustBuffer {
    return FfiConverterTypeBreezEvent.lower(value)
}


extension BreezEvent: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BuyBitcoinProvider {
    
    case `moonpay`
}

public struct FfiConverterTypeBuyBitcoinProvider: FfiConverterRustBuffer {
    typealias SwiftType = BuyBitcoinProvider

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BuyBitcoinProvider {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`moonpay`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BuyBitcoinProvider, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`moonpay`:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeBuyBitcoinProvider_lift(_ buf: RustBuffer) throws -> BuyBitcoinProvider {
    return try FfiConverterTypeBuyBitcoinProvider.lift(buf)
}

public func FfiConverterTypeBuyBitcoinProvider_lower(_ value: BuyBitcoinProvider) -> RustBuffer {
    return FfiConverterTypeBuyBitcoinProvider.lower(value)
}


extension BuyBitcoinProvider: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ChannelState {
    
    case `pendingOpen`
    case `opened`
    case `pendingClose`
    case `closed`
}

public struct FfiConverterTypeChannelState: FfiConverterRustBuffer {
    typealias SwiftType = ChannelState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChannelState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`pendingOpen`
        
        case 2: return .`opened`
        
        case 3: return .`pendingClose`
        
        case 4: return .`closed`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChannelState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`pendingOpen`:
            writeInt(&buf, Int32(1))
        
        
        case .`opened`:
            writeInt(&buf, Int32(2))
        
        
        case .`pendingClose`:
            writeInt(&buf, Int32(3))
        
        
        case .`closed`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeChannelState_lift(_ buf: RustBuffer) throws -> ChannelState {
    return try FfiConverterTypeChannelState.lift(buf)
}

public func FfiConverterTypeChannelState_lower(_ value: ChannelState) -> RustBuffer {
    return FfiConverterTypeChannelState.lower(value)
}


extension ChannelState: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum EnvironmentType {
    
    case `production`
    case `staging`
}

public struct FfiConverterTypeEnvironmentType: FfiConverterRustBuffer {
    typealias SwiftType = EnvironmentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnvironmentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`production`
        
        case 2: return .`staging`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnvironmentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`production`:
            writeInt(&buf, Int32(1))
        
        
        case .`staging`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeEnvironmentType_lift(_ buf: RustBuffer) throws -> EnvironmentType {
    return try FfiConverterTypeEnvironmentType.lift(buf)
}

public func FfiConverterTypeEnvironmentType_lower(_ value: EnvironmentType) -> RustBuffer {
    return FfiConverterTypeEnvironmentType.lower(value)
}


extension EnvironmentType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FeeratePreset {
    
    case `regular`
    case `economy`
    case `priority`
}

public struct FfiConverterTypeFeeratePreset: FfiConverterRustBuffer {
    typealias SwiftType = FeeratePreset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeratePreset {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`regular`
        
        case 2: return .`economy`
        
        case 3: return .`priority`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FeeratePreset, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`regular`:
            writeInt(&buf, Int32(1))
        
        
        case .`economy`:
            writeInt(&buf, Int32(2))
        
        
        case .`priority`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeFeeratePreset_lift(_ buf: RustBuffer) throws -> FeeratePreset {
    return try FfiConverterTypeFeeratePreset.lift(buf)
}

public func FfiConverterTypeFeeratePreset_lower(_ value: FeeratePreset) -> RustBuffer {
    return FfiConverterTypeFeeratePreset.lower(value)
}


extension FeeratePreset: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum HealthCheckStatus {
    
    case `operational`
    case `maintenance`
    case `serviceDisruption`
}

public struct FfiConverterTypeHealthCheckStatus: FfiConverterRustBuffer {
    typealias SwiftType = HealthCheckStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HealthCheckStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`operational`
        
        case 2: return .`maintenance`
        
        case 3: return .`serviceDisruption`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HealthCheckStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`operational`:
            writeInt(&buf, Int32(1))
        
        
        case .`maintenance`:
            writeInt(&buf, Int32(2))
        
        
        case .`serviceDisruption`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeHealthCheckStatus_lift(_ buf: RustBuffer) throws -> HealthCheckStatus {
    return try FfiConverterTypeHealthCheckStatus.lift(buf)
}

public func FfiConverterTypeHealthCheckStatus_lower(_ value: HealthCheckStatus) -> RustBuffer {
    return FfiConverterTypeHealthCheckStatus.lower(value)
}


extension HealthCheckStatus: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum InputType {
    
    case `bitcoinAddress`(`address`: BitcoinAddressData)
    case `bolt11`(`invoice`: LnInvoice)
    case `nodeId`(`nodeId`: String)
    case `url`(`url`: String)
    case `lnUrlPay`(`data`: LnUrlPayRequestData)
    case `lnUrlWithdraw`(`data`: LnUrlWithdrawRequestData)
    case `lnUrlAuth`(`data`: LnUrlAuthRequestData)
    case `lnUrlError`(`data`: LnUrlErrorData)
}

public struct FfiConverterTypeInputType: FfiConverterRustBuffer {
    typealias SwiftType = InputType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InputType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`bitcoinAddress`(
            `address`: try FfiConverterTypeBitcoinAddressData.read(from: &buf)
        )
        
        case 2: return .`bolt11`(
            `invoice`: try FfiConverterTypeLnInvoice.read(from: &buf)
        )
        
        case 3: return .`nodeId`(
            `nodeId`: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .`url`(
            `url`: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .`lnUrlPay`(
            `data`: try FfiConverterTypeLnUrlPayRequestData.read(from: &buf)
        )
        
        case 6: return .`lnUrlWithdraw`(
            `data`: try FfiConverterTypeLnUrlWithdrawRequestData.read(from: &buf)
        )
        
        case 7: return .`lnUrlAuth`(
            `data`: try FfiConverterTypeLnUrlAuthRequestData.read(from: &buf)
        )
        
        case 8: return .`lnUrlError`(
            `data`: try FfiConverterTypeLnUrlErrorData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InputType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`bitcoinAddress`(`address`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeBitcoinAddressData.write(`address`, into: &buf)
            
        
        case let .`bolt11`(`invoice`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnInvoice.write(`invoice`, into: &buf)
            
        
        case let .`nodeId`(`nodeId`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`nodeId`, into: &buf)
            
        
        case let .`url`(`url`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`url`, into: &buf)
            
        
        case let .`lnUrlPay`(`data`):
            writeInt(&buf, Int32(5))
            FfiConverterTypeLnUrlPayRequestData.write(`data`, into: &buf)
            
        
        case let .`lnUrlWithdraw`(`data`):
            writeInt(&buf, Int32(6))
            FfiConverterTypeLnUrlWithdrawRequestData.write(`data`, into: &buf)
            
        
        case let .`lnUrlAuth`(`data`):
            writeInt(&buf, Int32(7))
            FfiConverterTypeLnUrlAuthRequestData.write(`data`, into: &buf)
            
        
        case let .`lnUrlError`(`data`):
            writeInt(&buf, Int32(8))
            FfiConverterTypeLnUrlErrorData.write(`data`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeInputType_lift(_ buf: RustBuffer) throws -> InputType {
    return try FfiConverterTypeInputType.lift(buf)
}

public func FfiConverterTypeInputType_lower(_ value: InputType) -> RustBuffer {
    return FfiConverterTypeInputType.lower(value)
}


extension InputType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LnUrlCallbackStatus {
    
    case `ok`
    case `errorStatus`(`data`: LnUrlErrorData)
}

public struct FfiConverterTypeLnUrlCallbackStatus: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlCallbackStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlCallbackStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ok`
        
        case 2: return .`errorStatus`(
            `data`: try FfiConverterTypeLnUrlErrorData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlCallbackStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`ok`:
            writeInt(&buf, Int32(1))
        
        
        case let .`errorStatus`(`data`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlErrorData.write(`data`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLnUrlCallbackStatus_lift(_ buf: RustBuffer) throws -> LnUrlCallbackStatus {
    return try FfiConverterTypeLnUrlCallbackStatus.lift(buf)
}

public func FfiConverterTypeLnUrlCallbackStatus_lower(_ value: LnUrlCallbackStatus) -> RustBuffer {
    return FfiConverterTypeLnUrlCallbackStatus.lower(value)
}


extension LnUrlCallbackStatus: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LnUrlPayResult {
    
    case `endpointSuccess`(`data`: LnUrlPaySuccessData)
    case `endpointError`(`data`: LnUrlErrorData)
    case `payError`(`data`: LnUrlPayErrorData)
}

public struct FfiConverterTypeLnUrlPayResult: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlPayResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`endpointSuccess`(
            `data`: try FfiConverterTypeLnUrlPaySuccessData.read(from: &buf)
        )
        
        case 2: return .`endpointError`(
            `data`: try FfiConverterTypeLnUrlErrorData.read(from: &buf)
        )
        
        case 3: return .`payError`(
            `data`: try FfiConverterTypeLnUrlPayErrorData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlPayResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`endpointSuccess`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeLnUrlPaySuccessData.write(`data`, into: &buf)
            
        
        case let .`endpointError`(`data`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlErrorData.write(`data`, into: &buf)
            
        
        case let .`payError`(`data`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeLnUrlPayErrorData.write(`data`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLnUrlPayResult_lift(_ buf: RustBuffer) throws -> LnUrlPayResult {
    return try FfiConverterTypeLnUrlPayResult.lift(buf)
}

public func FfiConverterTypeLnUrlPayResult_lower(_ value: LnUrlPayResult) -> RustBuffer {
    return FfiConverterTypeLnUrlPayResult.lower(value)
}


extension LnUrlPayResult: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LnUrlWithdrawResult {
    
    case `ok`(`data`: LnUrlWithdrawSuccessData)
    case `errorStatus`(`data`: LnUrlErrorData)
}

public struct FfiConverterTypeLnUrlWithdrawResult: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlWithdrawResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ok`(
            `data`: try FfiConverterTypeLnUrlWithdrawSuccessData.read(from: &buf)
        )
        
        case 2: return .`errorStatus`(
            `data`: try FfiConverterTypeLnUrlErrorData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlWithdrawResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`ok`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeLnUrlWithdrawSuccessData.write(`data`, into: &buf)
            
        
        case let .`errorStatus`(`data`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeLnUrlErrorData.write(`data`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLnUrlWithdrawResult_lift(_ buf: RustBuffer) throws -> LnUrlWithdrawResult {
    return try FfiConverterTypeLnUrlWithdrawResult.lift(buf)
}

public func FfiConverterTypeLnUrlWithdrawResult_lower(_ value: LnUrlWithdrawResult) -> RustBuffer {
    return FfiConverterTypeLnUrlWithdrawResult.lower(value)
}


extension LnUrlWithdrawResult: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Network {
    
    case `bitcoin`
    case `testnet`
    case `signet`
    case `regtest`
}

public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`bitcoin`
        
        case 2: return .`testnet`
        
        case 3: return .`signet`
        
        case 4: return .`regtest`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`bitcoin`:
            writeInt(&buf, Int32(1))
        
        
        case .`testnet`:
            writeInt(&buf, Int32(2))
        
        
        case .`signet`:
            writeInt(&buf, Int32(3))
        
        
        case .`regtest`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NodeConfig {
    
    case `greenlight`(`config`: GreenlightNodeConfig)
}

public struct FfiConverterTypeNodeConfig: FfiConverterRustBuffer {
    typealias SwiftType = NodeConfig

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeConfig {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`greenlight`(
            `config`: try FfiConverterTypeGreenlightNodeConfig.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeConfig, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`greenlight`(`config`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeGreenlightNodeConfig.write(`config`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNodeConfig_lift(_ buf: RustBuffer) throws -> NodeConfig {
    return try FfiConverterTypeNodeConfig.lift(buf)
}

public func FfiConverterTypeNodeConfig_lower(_ value: NodeConfig) -> RustBuffer {
    return FfiConverterTypeNodeConfig.lower(value)
}


extension NodeConfig: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NodeCredentials {
    
    case `greenlight`(`credentials`: GreenlightCredentials)
}

public struct FfiConverterTypeNodeCredentials: FfiConverterRustBuffer {
    typealias SwiftType = NodeCredentials

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeCredentials {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`greenlight`(
            `credentials`: try FfiConverterTypeGreenlightCredentials.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeCredentials, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`greenlight`(`credentials`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeGreenlightCredentials.write(`credentials`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNodeCredentials_lift(_ buf: RustBuffer) throws -> NodeCredentials {
    return try FfiConverterTypeNodeCredentials.lift(buf)
}

public func FfiConverterTypeNodeCredentials_lower(_ value: NodeCredentials) -> RustBuffer {
    return FfiConverterTypeNodeCredentials.lower(value)
}


extension NodeCredentials: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentDetails {
    
    case `ln`(`data`: LnPaymentDetails)
    case `closedChannel`(`data`: ClosedChannelPaymentDetails)
}

public struct FfiConverterTypePaymentDetails: FfiConverterRustBuffer {
    typealias SwiftType = PaymentDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`ln`(
            `data`: try FfiConverterTypeLnPaymentDetails.read(from: &buf)
        )
        
        case 2: return .`closedChannel`(
            `data`: try FfiConverterTypeClosedChannelPaymentDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`ln`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeLnPaymentDetails.write(`data`, into: &buf)
            
        
        case let .`closedChannel`(`data`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeClosedChannelPaymentDetails.write(`data`, into: &buf)
            
        }
    }
}


public func FfiConverterTypePaymentDetails_lift(_ buf: RustBuffer) throws -> PaymentDetails {
    return try FfiConverterTypePaymentDetails.lift(buf)
}

public func FfiConverterTypePaymentDetails_lower(_ value: PaymentDetails) -> RustBuffer {
    return FfiConverterTypePaymentDetails.lower(value)
}


extension PaymentDetails: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentStatus {
    
    case `pending`
    case `complete`
    case `failed`
}

public struct FfiConverterTypePaymentStatus: FfiConverterRustBuffer {
    typealias SwiftType = PaymentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`pending`
        
        case 2: return .`complete`
        
        case 3: return .`failed`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`pending`:
            writeInt(&buf, Int32(1))
        
        
        case .`complete`:
            writeInt(&buf, Int32(2))
        
        
        case .`failed`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypePaymentStatus_lift(_ buf: RustBuffer) throws -> PaymentStatus {
    return try FfiConverterTypePaymentStatus.lift(buf)
}

public func FfiConverterTypePaymentStatus_lower(_ value: PaymentStatus) -> RustBuffer {
    return FfiConverterTypePaymentStatus.lower(value)
}


extension PaymentStatus: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentType {
    
    case `sent`
    case `received`
    case `closedChannel`
}

public struct FfiConverterTypePaymentType: FfiConverterRustBuffer {
    typealias SwiftType = PaymentType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`sent`
        
        case 2: return .`received`
        
        case 3: return .`closedChannel`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`sent`:
            writeInt(&buf, Int32(1))
        
        
        case .`received`:
            writeInt(&buf, Int32(2))
        
        
        case .`closedChannel`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypePaymentType_lift(_ buf: RustBuffer) throws -> PaymentType {
    return try FfiConverterTypePaymentType.lift(buf)
}

public func FfiConverterTypePaymentType_lower(_ value: PaymentType) -> RustBuffer {
    return FfiConverterTypePaymentType.lower(value)
}


extension PaymentType: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PaymentTypeFilter {
    
    case `sent`
    case `received`
    case `closedChannel`
}

public struct FfiConverterTypePaymentTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = PaymentTypeFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PaymentTypeFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`sent`
        
        case 2: return .`received`
        
        case 3: return .`closedChannel`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PaymentTypeFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`sent`:
            writeInt(&buf, Int32(1))
        
        
        case .`received`:
            writeInt(&buf, Int32(2))
        
        
        case .`closedChannel`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypePaymentTypeFilter_lift(_ buf: RustBuffer) throws -> PaymentTypeFilter {
    return try FfiConverterTypePaymentTypeFilter.lift(buf)
}

public func FfiConverterTypePaymentTypeFilter_lower(_ value: PaymentTypeFilter) -> RustBuffer {
    return FfiConverterTypePaymentTypeFilter.lower(value)
}


extension PaymentTypeFilter: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ReportIssueRequest {
    
    case `paymentFailure`(`data`: ReportPaymentFailureDetails)
}

public struct FfiConverterTypeReportIssueRequest: FfiConverterRustBuffer {
    typealias SwiftType = ReportIssueRequest

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReportIssueRequest {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`paymentFailure`(
            `data`: try FfiConverterTypeReportPaymentFailureDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReportIssueRequest, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`paymentFailure`(`data`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeReportPaymentFailureDetails.write(`data`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeReportIssueRequest_lift(_ buf: RustBuffer) throws -> ReportIssueRequest {
    return try FfiConverterTypeReportIssueRequest.lift(buf)
}

public func FfiConverterTypeReportIssueRequest_lower(_ value: ReportIssueRequest) -> RustBuffer {
    return FfiConverterTypeReportIssueRequest.lower(value)
}


extension ReportIssueRequest: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ReverseSwapStatus {
    
    case `initial`
    case `inProgress`
    case `cancelled`
    case `completedSeen`
    case `completedConfirmed`
}

public struct FfiConverterTypeReverseSwapStatus: FfiConverterRustBuffer {
    typealias SwiftType = ReverseSwapStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReverseSwapStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`initial`
        
        case 2: return .`inProgress`
        
        case 3: return .`cancelled`
        
        case 4: return .`completedSeen`
        
        case 5: return .`completedConfirmed`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReverseSwapStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`initial`:
            writeInt(&buf, Int32(1))
        
        
        case .`inProgress`:
            writeInt(&buf, Int32(2))
        
        
        case .`cancelled`:
            writeInt(&buf, Int32(3))
        
        
        case .`completedSeen`:
            writeInt(&buf, Int32(4))
        
        
        case .`completedConfirmed`:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeReverseSwapStatus_lift(_ buf: RustBuffer) throws -> ReverseSwapStatus {
    return try FfiConverterTypeReverseSwapStatus.lift(buf)
}

public func FfiConverterTypeReverseSwapStatus_lower(_ value: ReverseSwapStatus) -> RustBuffer {
    return FfiConverterTypeReverseSwapStatus.lower(value)
}


extension ReverseSwapStatus: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SuccessActionProcessed {
    
    case `aes`(`result`: AesSuccessActionDataResult)
    case `message`(`data`: MessageSuccessActionData)
    case `url`(`data`: UrlSuccessActionData)
}

public struct FfiConverterTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessActionProcessed {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`aes`(
            `result`: try FfiConverterTypeAesSuccessActionDataResult.read(from: &buf)
        )
        
        case 2: return .`message`(
            `data`: try FfiConverterTypeMessageSuccessActionData.read(from: &buf)
        )
        
        case 3: return .`url`(
            `data`: try FfiConverterTypeUrlSuccessActionData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SuccessActionProcessed, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .`aes`(`result`):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAesSuccessActionDataResult.write(`result`, into: &buf)
            
        
        case let .`message`(`data`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeMessageSuccessActionData.write(`data`, into: &buf)
            
        
        case let .`url`(`data`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeUrlSuccessActionData.write(`data`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSuccessActionProcessed_lift(_ buf: RustBuffer) throws -> SuccessActionProcessed {
    return try FfiConverterTypeSuccessActionProcessed.lift(buf)
}

public func FfiConverterTypeSuccessActionProcessed_lower(_ value: SuccessActionProcessed) -> RustBuffer {
    return FfiConverterTypeSuccessActionProcessed.lower(value)
}


extension SuccessActionProcessed: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SwapStatus {
    
    case `initial`
    case `expired`
}

public struct FfiConverterTypeSwapStatus: FfiConverterRustBuffer {
    typealias SwiftType = SwapStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwapStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`initial`
        
        case 2: return .`expired`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SwapStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`initial`:
            writeInt(&buf, Int32(1))
        
        
        case .`expired`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeSwapStatus_lift(_ buf: RustBuffer) throws -> SwapStatus {
    return try FfiConverterTypeSwapStatus.lift(buf)
}

public func FfiConverterTypeSwapStatus_lower(_ value: SwapStatus) -> RustBuffer {
    return FfiConverterTypeSwapStatus.lower(value)
}


extension SwapStatus: Equatable, Hashable {}



public enum LnUrlAuthError {

    
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case InvalidUri(message: String)
    
    // Simple error enums only carry a message
    case ServiceConnectivity(message: String)
    
}

public struct FfiConverterTypeLnUrlAuthError: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlAuthError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlAuthError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidUri(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .ServiceConnectivity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlAuthError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Generic(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidUri(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .ServiceConnectivity(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension LnUrlAuthError: Equatable, Hashable {}

extension LnUrlAuthError: Error { }


public enum LnUrlPayError {

    
    
    // Simple error enums only carry a message
    case AlreadyPaid(message: String)
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case InvalidAmount(message: String)
    
    // Simple error enums only carry a message
    case InvalidInvoice(message: String)
    
    // Simple error enums only carry a message
    case InvalidNetwork(message: String)
    
    // Simple error enums only carry a message
    case InvalidUri(message: String)
    
    // Simple error enums only carry a message
    case InvoiceExpired(message: String)
    
    // Simple error enums only carry a message
    case PaymentFailed(message: String)
    
    // Simple error enums only carry a message
    case PaymentTimeout(message: String)
    
    // Simple error enums only carry a message
    case RouteNotFound(message: String)
    
    // Simple error enums only carry a message
    case RouteTooExpensive(message: String)
    
    // Simple error enums only carry a message
    case ServiceConnectivity(message: String)
    
}

public struct FfiConverterTypeLnUrlPayError: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlPayError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlPayError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AlreadyPaid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidAmount(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidInvoice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidNetwork(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidUri(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .InvoiceExpired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .PaymentFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .PaymentTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .RouteNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .RouteTooExpensive(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .ServiceConnectivity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlPayError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .AlreadyPaid(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .Generic(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidAmount(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidInvoice(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidNetwork(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidUri(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)
        case let .InvoiceExpired(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)
        case let .PaymentFailed(message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(message, into: &buf)
        case let .PaymentTimeout(message):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(message, into: &buf)
        case let .RouteNotFound(message):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(message, into: &buf)
        case let .RouteTooExpensive(message):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(message, into: &buf)
        case let .ServiceConnectivity(message):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension LnUrlPayError: Equatable, Hashable {}

extension LnUrlPayError: Error { }


public enum LnUrlWithdrawError {

    
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case InvalidAmount(message: String)
    
    // Simple error enums only carry a message
    case InvalidInvoice(message: String)
    
    // Simple error enums only carry a message
    case InvalidUri(message: String)
    
    // Simple error enums only carry a message
    case ServiceConnectivity(message: String)
    
}

public struct FfiConverterTypeLnUrlWithdrawError: FfiConverterRustBuffer {
    typealias SwiftType = LnUrlWithdrawError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LnUrlWithdrawError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidAmount(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidInvoice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidUri(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .ServiceConnectivity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LnUrlWithdrawError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Generic(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidAmount(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidInvoice(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidUri(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .ServiceConnectivity(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension LnUrlWithdrawError: Equatable, Hashable {}

extension LnUrlWithdrawError: Error { }


public enum ReceiveOnchainError {

    
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case ServiceConnectivity(message: String)
    
    // Simple error enums only carry a message
    case SwapInProgress(message: String)
    
}

public struct FfiConverterTypeReceiveOnchainError: FfiConverterRustBuffer {
    typealias SwiftType = ReceiveOnchainError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiveOnchainError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .ServiceConnectivity(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .SwapInProgress(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReceiveOnchainError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Generic(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .ServiceConnectivity(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .SwapInProgress(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension ReceiveOnchainError: Equatable, Hashable {}

extension ReceiveOnchainError: Error { }


public enum ReceivePaymentError {

    
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case InvalidAmount(message: String)
    
    // Simple error enums only carry a message
    case InvalidInvoice(message: String)
    
    // Simple error enums only carry a message
    case InvoiceExpired(message: String)
    
    // Simple error enums only carry a message
    case InvoiceNoDescription(message: String)
    
    // Simple error enums only carry a message
    case InvoicePreimageAlreadyExists(message: String)
    
    // Simple error enums only carry a message
    case ServiceConnectivity(message: String)
    
}

public struct FfiConverterTypeReceivePaymentError: FfiConverterRustBuffer {
    typealias SwiftType = ReceivePaymentError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceivePaymentError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidAmount(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidInvoice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvoiceExpired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvoiceNoDescription(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvoicePreimageAlreadyExists(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .ServiceConnectivity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReceivePaymentError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Generic(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidAmount(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidInvoice(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .InvoiceExpired(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .InvoiceNoDescription(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
        case let .InvoicePreimageAlreadyExists(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)
        case let .ServiceConnectivity(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension ReceivePaymentError: Equatable, Hashable {}

extension ReceivePaymentError: Error { }


public enum SdkError {

    
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case ServiceConnectivity(message: String)
    
}

public struct FfiConverterTypeSdkError: FfiConverterRustBuffer {
    typealias SwiftType = SdkError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdkError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .ServiceConnectivity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdkError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Generic(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .ServiceConnectivity(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension SdkError: Equatable, Hashable {}

extension SdkError: Error { }


public enum SendOnchainError {

    
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case InvalidDestinationAddress(message: String)
    
    // Simple error enums only carry a message
    case PaymentFailed(message: String)
    
    // Simple error enums only carry a message
    case PaymentTimeout(message: String)
    
    // Simple error enums only carry a message
    case ReverseSwapInProgress(message: String)
    
    // Simple error enums only carry a message
    case ServiceConnectivity(message: String)
    
}

public struct FfiConverterTypeSendOnchainError: FfiConverterRustBuffer {
    typealias SwiftType = SendOnchainError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendOnchainError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidDestinationAddress(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .PaymentFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .PaymentTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .ReverseSwapInProgress(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .ServiceConnectivity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendOnchainError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .Generic(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidDestinationAddress(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .PaymentFailed(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .PaymentTimeout(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .ReverseSwapInProgress(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
        case let .ServiceConnectivity(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension SendOnchainError: Equatable, Hashable {}

extension SendOnchainError: Error { }


public enum SendPaymentError {

    
    
    // Simple error enums only carry a message
    case AlreadyPaid(message: String)
    
    // Simple error enums only carry a message
    case Generic(message: String)
    
    // Simple error enums only carry a message
    case InvalidAmount(message: String)
    
    // Simple error enums only carry a message
    case InvalidInvoice(message: String)
    
    // Simple error enums only carry a message
    case InvoiceExpired(message: String)
    
    // Simple error enums only carry a message
    case InvalidNetwork(message: String)
    
    // Simple error enums only carry a message
    case PaymentFailed(message: String)
    
    // Simple error enums only carry a message
    case PaymentTimeout(message: String)
    
    // Simple error enums only carry a message
    case RouteNotFound(message: String)
    
    // Simple error enums only carry a message
    case RouteTooExpensive(message: String)
    
    // Simple error enums only carry a message
    case ServiceConnectivity(message: String)
    
}

public struct FfiConverterTypeSendPaymentError: FfiConverterRustBuffer {
    typealias SwiftType = SendPaymentError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendPaymentError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AlreadyPaid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidAmount(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidInvoice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvoiceExpired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidNetwork(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .PaymentFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .PaymentTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .RouteNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .RouteTooExpensive(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .ServiceConnectivity(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SendPaymentError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .AlreadyPaid(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
        case let .Generic(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidAmount(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidInvoice(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
        case let .InvoiceExpired(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
        case let .InvalidNetwork(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)
        case let .PaymentFailed(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)
        case let .PaymentTimeout(message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(message, into: &buf)
        case let .RouteNotFound(message):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(message, into: &buf)
        case let .RouteTooExpensive(message):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(message, into: &buf)
        case let .ServiceConnectivity(message):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(message, into: &buf)

        
        }
    }
}


extension SendPaymentError: Equatable, Hashable {}

extension SendPaymentError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for EventListener Callback Interface

public protocol EventListener : AnyObject {
    func `onEvent`(`e`: BreezEvent)
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceEventListener : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeOnEvent`(_ swiftCallbackInterface: EventListener, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`onEvent`(
                    `e`:  try FfiConverterTypeBreezEvent.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: EventListener
        do {
            cb = try FfiConverterCallbackInterfaceEventListener.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("EventListener: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceEventListener.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeOnEvent`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceEventListener {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_breez_sdk_76fc_EventListener_init_callback(foreignCallbackCallbackInterfaceEventListener, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<EventListener>()
}

extension FfiConverterCallbackInterfaceEventListener : FfiConverter {
    typealias SwiftType = EventListener
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for LogStream Callback Interface

public protocol LogStream : AnyObject {
    func `log`(`l`: LogEntry)
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceLogStream : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeLog`(_ swiftCallbackInterface: LogStream, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`log`(
                    `l`:  try FfiConverterTypeLogEntry.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: LogStream
        do {
            cb = try FfiConverterCallbackInterfaceLogStream.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("LogStream: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceLogStream.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeLog`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceLogStream {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_breez_sdk_76fc_LogStream_init_callback(foreignCallbackCallbackInterfaceLogStream, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<LogStream>()
}

extension FfiConverterCallbackInterfaceLogStream : FfiConverter {
    typealias SwiftType = LogStream
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeGreenlightCredentials: FfiConverterRustBuffer {
    typealias SwiftType = GreenlightCredentials?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeGreenlightCredentials.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeGreenlightCredentials.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLnInvoice: FfiConverterRustBuffer {
    typealias SwiftType = LnInvoice?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLnInvoice.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLnInvoice.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLspInformation: FfiConverterRustBuffer {
    typealias SwiftType = LspInformation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLspInformation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLspInformation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOpeningFeeParams: FfiConverterRustBuffer {
    typealias SwiftType = OpeningFeeParams?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOpeningFeeParams.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOpeningFeeParams.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = Payment?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePayment.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePayment.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSwapInfo: FfiConverterRustBuffer {
    typealias SwiftType = SwapInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSwapInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSwapInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSymbol: FfiConverterRustBuffer {
    typealias SwiftType = Symbol?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSymbol.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSymbol.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeNodeCredentials: FfiConverterRustBuffer {
    typealias SwiftType = NodeCredentials?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNodeCredentials.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNodeCredentials.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSuccessActionProcessed: FfiConverterRustBuffer {
    typealias SwiftType = SuccessActionProcessed?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessActionProcessed.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessActionProcessed.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeLocaleOverrides: FfiConverterRustBuffer {
    typealias SwiftType = [LocaleOverrides]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLocaleOverrides.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLocaleOverrides.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeLocalizedName: FfiConverterRustBuffer {
    typealias SwiftType = [LocalizedName]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLocalizedName.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLocalizedName.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypePaymentTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentTypeFilter]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePaymentTypeFilter.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePaymentTypeFilter.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer {
    typealias SwiftType = [FiatCurrency]

    public static func write(_ value: [FiatCurrency], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFiatCurrency.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FiatCurrency] {
        let len: Int32 = try readInt(&buf)
        var seq = [FiatCurrency]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFiatCurrency.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLocaleOverrides: FfiConverterRustBuffer {
    typealias SwiftType = [LocaleOverrides]

    public static func write(_ value: [LocaleOverrides], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocaleOverrides.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocaleOverrides] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocaleOverrides]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocaleOverrides.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLocalizedName: FfiConverterRustBuffer {
    typealias SwiftType = [LocalizedName]

    public static func write(_ value: [LocalizedName], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLocalizedName.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LocalizedName] {
        let len: Int32 = try readInt(&buf)
        var seq = [LocalizedName]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLocalizedName.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLspInformation: FfiConverterRustBuffer {
    typealias SwiftType = [LspInformation]

    public static func write(_ value: [LspInformation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLspInformation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LspInformation] {
        let len: Int32 = try readInt(&buf)
        var seq = [LspInformation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLspInformation.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOpeningFeeParams: FfiConverterRustBuffer {
    typealias SwiftType = [OpeningFeeParams]

    public static func write(_ value: [OpeningFeeParams], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOpeningFeeParams.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OpeningFeeParams] {
        let len: Int32 = try readInt(&buf)
        var seq = [OpeningFeeParams]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOpeningFeeParams.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePayment: FfiConverterRustBuffer {
    typealias SwiftType = [Payment]

    public static func write(_ value: [Payment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePayment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Payment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Payment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePayment.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRate: FfiConverterRustBuffer {
    typealias SwiftType = [Rate]

    public static func write(_ value: [Rate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Rate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Rate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRate.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeReverseSwapInfo: FfiConverterRustBuffer {
    typealias SwiftType = [ReverseSwapInfo]

    public static func write(_ value: [ReverseSwapInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReverseSwapInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReverseSwapInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReverseSwapInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReverseSwapInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRouteHint: FfiConverterRustBuffer {
    typealias SwiftType = [RouteHint]

    public static func write(_ value: [RouteHint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRouteHint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RouteHint] {
        let len: Int32 = try readInt(&buf)
        var seq = [RouteHint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRouteHint.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRouteHintHop: FfiConverterRustBuffer {
    typealias SwiftType = [RouteHintHop]

    public static func write(_ value: [RouteHintHop], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRouteHintHop.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RouteHintHop] {
        let len: Int32 = try readInt(&buf)
        var seq = [RouteHintHop]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRouteHintHop.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeSwapInfo: FfiConverterRustBuffer {
    typealias SwiftType = [SwapInfo]

    public static func write(_ value: [SwapInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSwapInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SwapInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [SwapInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSwapInfo.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUnspentTransactionOutput: FfiConverterRustBuffer {
    typealias SwiftType = [UnspentTransactionOutput]

    public static func write(_ value: [UnspentTransactionOutput], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnspentTransactionOutput.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UnspentTransactionOutput] {
        let len: Int32 = try readInt(&buf)
        var seq = [UnspentTransactionOutput]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnspentTransactionOutput.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePaymentTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [PaymentTypeFilter]

    public static func write(_ value: [PaymentTypeFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePaymentTypeFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PaymentTypeFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [PaymentTypeFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePaymentTypeFilter.read(from: &buf))
        }
        return seq
    }
}

public func `connect`(`config`: Config, `seed`: [UInt8], `listener`: EventListener) throws -> BlockingBreezServices {
    return try FfiConverterTypeBlockingBreezServices.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_76fc_connect(
        FfiConverterTypeConfig.lower(`config`),
        FfiConverterSequenceUInt8.lower(`seed`),
        FfiConverterCallbackInterfaceEventListener.lower(`listener`), $0)
}
    )
}



public func `setLogStream`(`logStream`: LogStream) throws {
    try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_76fc_set_log_stream(
        FfiConverterCallbackInterfaceLogStream.lower(`logStream`), $0)
}
}


public func `parseInvoice`(`invoice`: String) throws -> LnInvoice {
    return try FfiConverterTypeLnInvoice.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_76fc_parse_invoice(
        FfiConverterString.lower(`invoice`), $0)
}
    )
}



public func `parseInput`(`s`: String) throws -> InputType {
    return try FfiConverterTypeInputType.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_76fc_parse_input(
        FfiConverterString.lower(`s`), $0)
}
    )
}



public func `mnemonicToSeed`(`phrase`: String) throws -> [UInt8] {
    return try FfiConverterSequenceUInt8.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_76fc_mnemonic_to_seed(
        FfiConverterString.lower(`phrase`), $0)
}
    )
}



public func `defaultConfig`(`envType`: EnvironmentType, `apiKey`: String, `nodeConfig`: NodeConfig)  -> Config {
    return try! FfiConverterTypeConfig.lift(
        try!
    
    rustCall() {
    
    breez_sdk_76fc_default_config(
        FfiConverterTypeEnvironmentType.lower(`envType`),
        FfiConverterString.lower(`apiKey`),
        FfiConverterTypeNodeConfig.lower(`nodeConfig`), $0)
}
    )
}



public func `staticBackup`(`req`: StaticBackupRequest) throws -> StaticBackupResponse {
    return try FfiConverterTypeStaticBackupResponse.lift(
        try
    
    rustCallWithError(FfiConverterTypeSdkError.self) {
    
    breez_sdk_76fc_static_backup(
        FfiConverterTypeStaticBackupRequest.lower(`req`), $0)
}
    )
}



/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum BreezSdkLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}
